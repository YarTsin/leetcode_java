<h3> Решаем задачки LeetCode на Java </h3>
Пробуем собрать, разобрать и решить по нескольку задач в каждом направлении<br>
Задачи распределены по особенностям самих задач и их решений.<br>

Многие задачи могут находится одновременно в разных категориях.<br>
Если вы склонируете проект себе на компьютер, то вы сможете искать 
или наоборот проставлять метки к задачам например: 
#Easy, #Medium, #Array, #String и другие. 

Ко многим задачам добавлены комментарии и пояснения для лучшего понимания.
Также для многих задач приводятся альтернативные решения. 
Подходит как учебное пособие для начинающих.<br> 
Для работы используется Java 8<br>
Желаю вам удачно пройти алгоритмическую секцию!<br><br>

 
Жми ★ если понравилось.<br><br>

Моя статистика: [https://leetcode.com/u/YarTsin/](https://leetcode.com/u/YarTsin/) <br><br>


<b>Array (#Array)</b> <br> 
В этом разделе показываем часть задач, использующих массивы <br>
Примечания: мажоритарный элемент - элемент, который встречается более n/2 раз.
Harmonious Subsequence - Определим гармоничную подпоследовательность 
как подпоследовательность массива, в которой разница между 
максимальным и минимальным элементами равна ровно 1, например 3,2,2,2,3.
<br>
Level Easy (#Easy)<br>
[1. Two Sum](src/main/java/org/example/g0001_0100/s0001_two_sum) &nbsp;&nbsp;
[14. Longest Common Prefix](src/main/java/org/example/g0001_0100/s0014_longest_common_prefix) &nbsp;&nbsp;
[66. Plus One](src/main/java/org/example/g0001_0100/s0066_plus_one) &nbsp;&nbsp;
[88. Merge Sorted Array](src/main/java/org/example/g0001_0100/s0088_merge_sorted_array) &nbsp;&nbsp;
[169. Majority Element](src/main/java/org/example/g0101_0200/s0169_majority_element) &nbsp;&nbsp;
[217. Contains Duplicate](src/main/java/org/example/g0201_0300/s0217_contains_duplicate) &nbsp;&nbsp;
[219. Contains Duplicate II](src/main/java/org/example/g0201_0300/s0219_contains_duplicate_ii) &nbsp;&nbsp;
[252. Meeting Rooms](src/main/java/org/example/g0201_0300/s0252_meeting_rooms) &nbsp;&nbsp;
[268. Missing Number](src/main/java/org/example/g0201_0300/s0268_missing_number) &nbsp;&nbsp;
[349. Intersection Of Two Arrays](src/main/java/org/example/g0301_0400/s0349_intersection_of_two_arrays) &nbsp;&nbsp;
[350. Intersection Of Two Arrays II](src/main/java/org/example/g0301_0400/s0350_intersection_of_two_arrays_ii) &nbsp;&nbsp;
[414. Third Maximum Number](src/main/java/org/example/g0401_0500/s0414_third_maximum_number) &nbsp;&nbsp;
[455. Assign Cookies](src/main/java/org/example/g0401_0500/s0455_assign_cookies) &nbsp;&nbsp;
[506. Relative Ranks](src/main/java/org/example/g0501_0600/s0506_relative_ranks) &nbsp;&nbsp;
[561. Array Partition I](src/main/java/org/example/g0501_0600/s0561_array_partition_i) &nbsp;&nbsp;
[594. Longest Harmonious Subsequence](src/main/java/org/example/g0501_0600/s0594_longest_harmonious_subsequence) &nbsp;&nbsp;
[628. Maximum Product Of Three Numbers](src/main/java/org/example/g0601_0700/s0628_maximum_product_of_three_numbers) &nbsp;&nbsp;
[645. Set Mismatch](src/main/java/org/example/g0601_0700/s0645_set_mismatch) &nbsp;&nbsp;
[860. Lemonade Change](src/main/java/org/example/g0801_0900/s0860_lemonade_change) &nbsp;&nbsp;
[2900. Longest Unequal Adjacent Groups Subsequence I](src/main/java/org/example/g2801_2900/p2900_longest_unequal_adjacent_groups_subsequence_i) &nbsp;&nbsp;
<br><br>

<b>Breadth-First Search (#BFS)</b>
Breadth First Search (BFS) — это алгоритм обхода или поиска в графе 
или дереве в ширину, который изучает все узлы на одном уровне перед 
переходом к следующему уровню. Проще говоря, он сначала посещает 
всех соседей начальной точки, потом их соседей и так далее, 
двигаясь "по ширине". Это, например, помогает найти кратчайший путь  
в невзвешенных графах.<br>
Примечание: Невзвешенный граф — это граф, в котором ребрам 
не присвоены какие-либо числовые значения (веса). То есть все ребра 
считаются равнозначными, без указания стоимости, длины или другого 
параметра. В таком графе при поиске пути или обходе обычно учитывается 
только количество ребер, а не их "вес". Например, если ребро соединяет 
две вершины, то переход по нему считается одинаково "дорогим" для всех ребер.
Level Easy (#Easy)<br>
[100. Same Tree](src/main/java/org/example/g0001_0100/s0100_same_tree) &nbsp;&nbsp;
[101. Symmetric Tree](src/main/java/org/example/g0101_0200/s0101_symmetric_tree) &nbsp;&nbsp;
[104. Maximum Depth Of Binary Tree](src/main/java/org/example/g0101_0200/s0104_maximum_depth_of_binary_tree) &nbsp;&nbsp;
<br><br>



<b>Binary Search (#BinarySearch)</b> <br>
Здесь помещаем задачи с бинарным поиском. Binary Search (бинарный поиск) 
— это алгоритм поиска элемента в отсортированном массиве, который делит область 
поиска пополам на каждом шаге.<br>
Level Easy (#Easy)<br>
[35. Search Insert Position](src/main/java/org/example/g0001_0100/s0035_search_insert_position) &nbsp;&nbsp;
[69. Sqrtx](src/main/java/org/example/g0001_0100/s0069_sqrtx) &nbsp;&nbsp;
[108. Convert Sorted Array To Binary Search Tree](src/main/java/org/example/g0101_0200/s0108_convert_sorted_array_to_binary_search_tree) &nbsp;&nbsp;
[367. Valid Perfect Square](src/main/java/org/example/g0301_0400/s0367_valid_perfect_square) &nbsp;&nbsp;
<br><br>


<b>Binary Search Tree (#BST)</b> <br>
BST (Binary Search Tree) — это структура данных в виде бинарного дерева с упорядочиванием, 
где для каждого узла значения в левом поддереве меньше значения узла, 
а в правом поддереве — больше.<br>
Level Easy (#Easy)<br>
[108. Convert Sorted Array To Binary Search Tree](src/main/java/org/example/g0101_0200/s0108_convert_sorted_array_to_binary_search_tree) &nbsp;&nbsp;
<br><br>

<b>Binary Tree (#BinaryTree)</b> <br>
Бинарное дерево — это иерархическая структура данных, в которой каждый 
узел (элемент) имеет не более двух потомков (детей). 

<details>
<summary>Информация по бинарным деревьям </summary>
(эта информация поможет разобраться в типах задач по бинарным деревьям)<br>
Этих потомков принято называть левым и правым ребенком. Ключевые компоненты:<br>
~ Корень (Root): Самый верхний узел дерева, от которого всё начинается. 
У корня нет родительского узла.<br>
~ Узел (Node): Элемент дерева, который хранит какие-то данные (например, число) 
и ссылки (указатели) на своих левого и правого потомков.<br>
~ Лист (Leaf): Узел, у которого нет потомков (оба ребенка равны null).<br>
Бинарные деревья — идеальный полигон для отработки понимания рекурсии и алгоритмов поиска в глубину (DFS) и поиска в ширину (BFS), 
которые являются краеугольным камнем многих сложных задач.<br> 
Основные типы бинарных деревьев: <br>
~ полное бинарное дерево: Все уровни дерева, кроме, возможно, последнего, полностью заполнены, а узлы последнего уровня смещены влево.<br>
~ сбалансированное бинарное дерево: Глубина левого и правого поддеревьев каждого узла 
отличается не более чем на единицу. Это важно для эффективности операций. Пример — AVL-дерево. <br>
~ идеальное бинарное дерево: Все внутренние узлы имеют двух детей, а все листья находятся на одном уровне.<br>
~ Бинарное дерево поиска (BST) — очень важный вид деревьев. <br>
Свойства: Для любого узла X: Все значения в левом поддереве X меньше значения самого X.
Все значения в правом поддереве X больше значения самого X. Это свойство позволяет очень 
эффективно (за время O(log n)) искать, добавлять и удалять элементы. 
Множество задач построено вокруг BST. <br>

<b>Базовые операции и обходы (Traversal)</b> <br>
Умение обходить дерево — ключ к решению >90% задач. Есть два основных подхода. <br>
Поиск в ширину (BFS - Breadth-First Search) - обход дерева уровень за уровнем. Реализуется с помощью очереди.
Частный случай: Level Order Traversal — классическая задача (например, LeetCode 102).<br>
Поиск в глубину (DFS - Depth-First Search)  - обход, при котором вы идете вглубь до самого конца, прежде чем вернуться. 
Имеет три основных вида, которые отличаются порядком обработки узла: <br>
~ Inorder (Лево -> Корень -> Право): Для BST обход дает отсортированную 
последовательность. Классическая задача: LeetCode 94.<br>
~ Preorder (Корень -> Лево -> Право): Полезно для копирования структуры дерева. 
Классическая задача: LeetCode 144. <br>
~ Postorder (Лево -> Право -> Корень): Полезно для удаления дерева, так как 
вы сначала работаете с детьми. Классическая задача: LeetCode 145.
</details>

Level Easy (#Easy)<br>
[94. Binary Tree Inorder Traversal](src/main/java/org/example/g0001_0100/s0094_binary_tree_inorder_traversal) &nbsp;&nbsp;
[100. Same Tree](src/main/java/org/example/g0001_0100/s0100_same_tree) &nbsp;&nbsp;
[101. Symmetric Tree](src/main/java/org/example/g0101_0200/s0101_symmetric_tree) &nbsp;&nbsp;
[104. Maximum Depth Of Binary Tree](src/main/java/org/example/g0101_0200/s0104_maximum_depth_of_binary_tree) &nbsp;&nbsp;
[108. Convert Sorted Array To Binary Search Tree](src/main/java/org/example/g0101_0200/s0108_convert_sorted_array_to_binary_search_tree) &nbsp;&nbsp;
[110. Balanced Binary Tree](src/main/java/org/example/g0101_0200/s0110_balanced_binary_tree) &nbsp;&nbsp;
[257. Binary Tree Paths](src/main/java/org/example/g0201_0300/s0257_binary_tree_paths)
<br><br>

<b>Bits (#Bits)</b> <br>
Операции с битами <br>
Level Easy (#Easy)<br>
[67. Add Binary](src/main/java/org/example/g0001_0100/s0067_add_binary)
[231. Power Of Two](src/main/java/org/example/g0201_0300/s0231_power_of_two) &nbsp;&nbsp;
[268. Missing Number](src/main/java/org/example/g0201_0300/s0268_missing_number) &nbsp;&nbsp;
[338. Counting Bits](src/main/java/org/example/g0301_0400/s0338_counting_bits) &nbsp;&nbsp;
[342. Power Of Four](src/main/java/org/example/g0301_0400/s0342_power_of_four) &nbsp;&nbsp;
[389. Find The Difference](src/main/java/org/example/g0301_0400/s0389_find_the_difference) &nbsp;&nbsp;
[405. Convert A Number TO Hexadecimal](src/main/java/org/example/g0401_0500/s0405_convert_a_number_to_hexadecimal) &nbsp;&nbsp;
<br><br>


<b>Depth-First Search (#DFS)</b><br>
Раздел посвящён задачам, которые можно решать с помощью алгоритма поиска в глубину.
DFS (поиск в глубину) — это один из базовых алгоритмов обхода или поиска в графах 
и деревьях. Идея заключается в том, что мы начинаем с корня (или с какой-то начальной вершины) 
и исследуем как можно глубже каждую ветвь перед тем, как перейти к следующей.<br>
Примечания: <br>
Граф — это множество вершин (узлов), связанных рёбрами (связями). 
Рёбра могут быть направленными или ненаправленными, граф может содержать циклы.<br>
Дерево — это частный случай графа: связный ацикличный граф, где между любой парой 
вершин существует ровно один путь. Дерево обычно имеет один корень.<br>
Максимальная глубина бинарного дерева - это количество узлов вдоль самого 
длинного пути от корневого узла до самого дальнего листового узла.<br>
Level Easy (#Easy)<br>
[94. Binary Tree Inorder Traversal](src/main/java/org/example/g0001_0100/s0094_binary_tree_inorder_traversal) &nbsp;&nbsp;
[100. Same Tree](src/main/java/org/example/g0001_0100/s0100_same_tree) &nbsp;&nbsp;
[101. Symmetric Tree](src/main/java/org/example/g0101_0200/s0101_symmetric_tree) &nbsp;&nbsp;
[104. Maximum Depth Of Binary Tree](src/main/java/org/example/g0101_0200/s0104_maximum_depth_of_binary_tree) &nbsp;&nbsp;
[110. Balanced Binary Tree](src/main/java/org/example/g0101_0200/s0110_balanced_binary_tree) &nbsp;&nbsp;
[257. Binary Tree Paths](src/main/java/org/example/g0201_0300/s0257_binary_tree_paths)
<br><br>


<b>Dynamic Programming (#DP)</b> <br>
Динамическое программирование (DP) — это метод решения задач, 
которые можно разбить на похожие подзадачи. Идея в том, 
чтобы не считать одну и ту же подзадачу несколько раз, 
а сохранить её результат и использовать повторно. <br>
Пример: вычисление чисел Фибоначчи. Вместо того, чтобы каждый 
раз вычислять число заново, мы запоминаем уже посчитанные значения 
и берём их из памяти.<br>
В Java обычно делают так: создают массив или таблицу для хранения результатов подзадач,
заполняют этот массив постепенно, начиная с самых простых случаев, 
используют сохранённые результаты для решения более сложных задач.<br>
Level Easy (#Easy)<br>
[70. Climbing Stairs](src/main/java/org/example/g0001_0100/s0070_climbing_stairs)  &nbsp;&nbsp;
[292. Nim Game](src/main/java/org/example/g0201_0300/s0292_nim_game) &nbsp;&nbsp;
[746. Min Cost Climbing Stairs](src/main/java/org/example/g0701_0800/s0746_min_cost_climbing_stairs) &nbsp;&nbsp;
[509. Fibonacci Number](src/main/java/org/example/g0501_0600/s0509_fibonacci_number) &nbsp;&nbsp;
[1137. N th Tribonacci Number](src/main/java/org/example/g1101_1200/s1137_n_th_tribonacci_number) &nbsp;&nbsp;
<br><br>


<b>Greedy (#Greedy)</b><br>
Задачи использующие "Жадный алгоритм"<br>
Жадный алгоритм — это способ решения задач, где на каждом шаге выбирается 
самый выгодный или лучший вариант в данный момент, не задумываясь о будущем. 
Такой подход прост и часто эффективен, но не всегда гарантирует 
оптимальное решение. Пример: выбор монет для сдачи, когда берём 
сначала самые крупные монеты.
<br>
Level Easy (#Easy)<br>
[455. Assign Cookies](src/main/java/org/example/g0401_0500/s0455_assign_cookies) &nbsp;&nbsp;
[561. Array Partition I](src/main/java/org/example/g0501_0600/s0561_array_partition_i) &nbsp;&nbsp;
[605. Can Place Flowers](src/main/java/org/example/g0601_0700/s0605_can_place_flowers) &nbsp;&nbsp;
[680. Valid Palindrome II](src/main/java/org/example/g0601_0700/s0680_valid_palindrome_ii) &nbsp;&nbsp;
[860. Lemonade Change](src/main/java/org/example/g0801_0900/s0860_lemonade_change) &nbsp;&nbsp;
[942. DI String Match](src/main/java/org/example/g0901_1000/s0942_di_string_match) &nbsp;&nbsp;
[976. Largest Perimeter Triangle](src/main/java/org/example/g0901_1000/s0976_largest_perimeter_triangle) &nbsp;&nbsp;
[1005. Maximize Sum Of Array After K Negations](src/main/java/org/example/g1001_1100/s1005_maximize_sum_of_array_after_k_negations) &nbsp;&nbsp;
[1013. Partition Array Into Three Parts With Equal Sum](src/main/java/org/example/g1001_1100/s1013_partition_array_into_three_parts_with_equal_sum) &nbsp;&nbsp;
[1217. Minimum Cost To Move Chips To The Same Position](src/main/java/org/example/g1201_1300/s1217_minimum_cost_to_move_chips_to_the_same_position) &nbsp;&nbsp;
<br><br>


<b>Hash Table (#HashMap)</b><br>
В этом разделе находятся задачи, использующие для решения хеш таблицы, 
например HashMap, HashSet<br>
Level Easy (#Easy)<br>
[1. Two Sum](src/main/java/org/example/g0001_0100/s0001_two_sum) &nbsp;&nbsp;
[205. Isomorphic Strings](src/main/java/org/example/g0201_0300/s0205_isomorphic_strings) &nbsp;&nbsp;
[290. Word Pattern](src/main/java/org/example/g0201_0300/s0290_word_pattern) &nbsp;&nbsp;
[349. Intersection Of Two Arrays](src/main/java/org/example/g0301_0400/s0349_intersection_of_two_arrays) &nbsp;&nbsp;
[350. Intersection Of Two Arrays II](src/main/java/org/example/g0301_0400/s0350_intersection_of_two_arrays_ii) &nbsp;&nbsp;
[594. Longest Harmonious Subsequence](src/main/java/org/example/g0501_0600/s0594_longest_harmonious_subsequence) &nbsp;&nbsp;
[888. Fair Candy Swap](src/main/java/org/example/g0801_0900/s0888_fair_candy_swap)
<br><br>


<b>Linked List</b><br>
Задачи, связанные со связанными списками<br>
Примечания. <br>
Можно сказать, что хорошее знание Linked List (связанных списков) 
полезно для изучения более сложной темы - разного рода деревьев.<br>
Алгоритм "Черепахи и Зайца" - Floyd's Cycle-Finding Algorithm<br>
Level Easy (#Easy)<br>
[141. Linked List Cycle](src/main/java/org/example/g0101_0200/s0141_linked_list_cycle) &nbsp;&nbsp;
[160. Intersection Of Two Linked Lists](src/main/java/org/example/g0101_0200/s0160_intersection_of_two_linked_lists) &nbsp;&nbsp;
<br><br>


<b>Math (#Math)</b><br>
Как правило это зачи с цифрами, числами, или использующие какие-то 
математические свойства и особенности<br>
Примечения: Палиндром - это число (или строка), которое читается одинаково 
в обоих направлениях. 
Цифровой корень числа — это однозначное число, которое получается путём 
последовательного сложения всех цифр исходного числа, пока не останется одна цифра.
Полный квадрат — это целое число, которое является квадратом
другого целого числа. Треугольник существует если выполняется неравенство треугольника:
сумма любых двух сторон должна быть больше третьей стороны.
<br>
Level Easy (#Easy)<br>
[9. Palindrome number](src/main/java/org/example/g0001_0100/s0009_palindrome_number) &nbsp;&nbsp;
[69. Sqrtx](src/main/java/org/example/g0001_0100/s0069_sqrtx) &nbsp;&nbsp;
[118. Pascals Triangle](src/main/java/org/example/g0101_0200/s0118_pascals_triangle) &nbsp;&nbsp;
[119. Pascals Triangle II](src/main/java/org/example/g0101_0200/s0119_pascals_triangle_ii) &nbsp;&nbsp;
[202. Happy Number](src/main/java/org/example/g0201_0300/s0202_happy_number) &nbsp;&nbsp;
[263. Ugly Number](src/main/java/org/example/g0201_0300/s0263_ugly_number) &nbsp;&nbsp;
[258. Add Digits](src/main/java/org/example/g0201_0300/s0258_add_digits) &nbsp;&nbsp;
[292. Nim Game](src/main/java/org/example/g0201_0300/s0292_nim_game) &nbsp;&nbsp;
[326. Power Of Three](src/main/java/org/example/g0301_0400/s0326_power_of_three) &nbsp;&nbsp;
[342. Power Of Four](src/main/java/org/example/g0301_0400/s0342_power_of_four) &nbsp;&nbsp;
[367. Valid Perfect Square](src/main/java/org/example/g0301_0400/s0367_valid_perfect_square) &nbsp;&nbsp;
[405. Convert A Number TO Hexadecimal](src/main/java/org/example/g0401_0500/s0405_convert_a_number_to_hexadecimal) &nbsp;&nbsp;
[628. Maximum Product Of Three Numbers](src/main/java/org/example/g0601_0700/s0628_maximum_product_of_three_numbers) &nbsp;&nbsp;
[645. Set Mismatch](src/main/java/org/example/g0601_0700/s0645_set_mismatch) &nbsp;&nbsp;
[942. DI String Match](src/main/java/org/example/g0901_1000/s0942_di_string_match) &nbsp;&nbsp;
[976. Largest Perimeter Triangle](src/main/java/org/example/g0901_1000/s0976_largest_perimeter_triangle) &nbsp;&nbsp;
[1217. Minimum Cost To Move Chips To The Same Position](src/main/java/org/example/g1201_1300/s1217_minimum_cost_to_move_chips_to_the_same_position) &nbsp;&nbsp;
[1025. Divisor game](src/main/java/org/example/g1001_1100/s1025_divisor_game) &nbsp;&nbsp;
<br><br>


<b>Pointers (#Pointers) - указатели</b><br>
Здесь показываем задачи, которые используют указатели для решения задач<br>
Level Easy (#Easy)<br>
[26. Remove Duplicates From Sorted Array](src/main/java/org/example/g0001_0100/s0026_remove_duplicates_from_sorted_array) &nbsp;&nbsp;
[27. Remove Element](src/main/java/org/example/g0001_0100/s0027_remove_element) &nbsp;&nbsp;
[125. Valid Palindrome](src/main/java/org/example/g0101_0200/s0125_valid_palindrome) &nbsp;&nbsp;
[141. Linked List Cycle](src/main/java/org/example/g0101_0200/s0141_linked_list_cycle) &nbsp;&nbsp;
[392. Is Subsequence](src/main/java/org/example/g0301_0400/s0392_is_subsequence) &nbsp;&nbsp;
[455. Assign Cookies](src/main/java/org/example/g0401_0500/s0455_assign_cookies) &nbsp;&nbsp;
[680. Valid Palindrome II](src/main/java/org/example/g0601_0700/s0680_valid_palindrome_ii) &nbsp;&nbsp;
[905. Sort Array By Parity](src/main/java/org/example/g0901_1000/s0905_sort_array_by_parity) &nbsp;&nbsp;
[942. DI String Match](src/main/java/org/example/g0901_1000/s0942_di_string_match) &nbsp;&nbsp;
<br><br>


<b>Recursion (#Recursion)- рекурсия</b><br>
Сюда помещаем примеры задач, которые могут использовать рекурсию в одном из решений <br>
Level Easy (#Easy)<br>
[94. Binary Tree Inorder Traversal](src/main/java/org/example/g0001_0100/s0094_binary_tree_inorder_traversal) &nbsp;&nbsp;
[100. Same Tree](src/main/java/org/example/g0001_0100/s0100_same_tree) &nbsp;&nbsp;
[101. Symmetric Tree](src/main/java/org/example/g0101_0200/s0101_symmetric_tree) &nbsp;&nbsp;
[104. Maximum Depth Of Binary Tree](src/main/java/org/example/g0101_0200/s0104_maximum_depth_of_binary_tree) &nbsp;&nbsp;
[108. Convert Sorted Array To Binary Search Tree](src/main/java/org/example/g0101_0200/s0108_convert_sorted_array_to_binary_search_tree) &nbsp;&nbsp;
[110. Balanced Binary Tree](src/main/java/org/example/g0101_0200/s0110_balanced_binary_tree) &nbsp;&nbsp;
[171. Excel Sheet Column Number](src/main/java/org/example/g0101_0200/s0171_excel_sheet_column_number) &nbsp;&nbsp;
[509. Fibonacci Number](src/main/java/org/example/g0501_0600/s0509_fibonacci_number) &nbsp;&nbsp;
[680. Valid Palindrome II](src/main/java/org/example/g0601_0700/s0680_valid_palindrome_ii) &nbsp;&nbsp;
[1137. N th Tribonacci Number](src/main/java/org/example/g1101_1200/s1137_n_th_tribonacci_number) &nbsp;&nbsp;
<br><br>


<b>Sort (#Sort)</b><br>
Задачи, использующие для решения сортировку<br>
Level Easy (#Easy)<br>
[252. Meeting Rooms](src/main/java/org/example/g0201_0300/s0252_meeting_rooms) &nbsp;&nbsp;
[414. Third Maximum Number](src/main/java/org/example/g0401_0500/s0414_third_maximum_number) &nbsp;&nbsp;
[455. Assign Cookies](src/main/java/org/example/g0401_0500/s0455_assign_cookies) &nbsp;&nbsp;
[506. Relative Ranks](src/main/java/org/example/g0501_0600/s0506_relative_ranks) &nbsp;&nbsp;
[561. Array Partition I](src/main/java/org/example/g0501_0600/s0561_array_partition_i) &nbsp;&nbsp;
[594. Longest Harmonious Subsequence](src/main/java/org/example/g0501_0600/s0594_longest_harmonious_subsequence) &nbsp;&nbsp;
[628. Maximum Product Of Three Numbers](src/main/java/org/example/g0601_0700/s0628_maximum_product_of_three_numbers) &nbsp;&nbsp;
[905. Sort Array By Parity](src/main/java/org/example/g0901_1000/s0905_sort_array_by_parity) &nbsp;&nbsp;
[976. Largest Perimeter Triangle](src/main/java/org/example/g0901_1000/s0976_largest_perimeter_triangle) &nbsp;&nbsp;
[1005. Maximize Sum Of Array After K Negations](src/main/java/org/example/g1001_1100/s1005_maximize_sum_of_array_after_k_negations) &nbsp;&nbsp;
<br><br>


<b>String (#String)</b><br>
В этом разделе находятся некоторые задачи, использующие строки<br>
Примечания: Подпоследовательность (subsequence) - это последовательность символов,
которая появляется в том же порядке, но не обязательно подряд.
Две строки считаются изоморфными, если символы первой строки 
 могут быть заменены на символы второй строки с сохранением порядка.
<br>
Level Easy (#Easy)<br>
[13. Roman To Integer](src/main/java/org/example/g0001_0100/s0013_roman_to_integer) &nbsp;&nbsp;
[14. Longest Common Prefix](src/main/java/org/example/g0001_0100/s0014_longest_common_prefix) &nbsp;&nbsp;
[20. Valid Parentheses](src/main/java/org/example/g0001_0100/s0020_valid_parentheses) &nbsp;&nbsp;
[28. Find The Index Of The First Occurrence In A String](src/main/java/org/example/g0001_0100/s0028_find_the_index_of_the_first_occurrence_in_a_string) &nbsp;&nbsp;
[58. Length Of Last Word](src/main/java/org/example/g0001_0100/s0058_length_of_last_word) &nbsp;&nbsp;
[67. Add Binary](src/main/java/org/example/g0001_0100/s0067_add_binary) &nbsp;&nbsp;
[125. Valid Palindrome](src/main/java/org/example/g0101_0200/s0125_valid_palindrome) &nbsp;&nbsp;
[168. Excel Sheet Column Title](src/main/java/org/example/g0101_0200/s0168_excel_sheet_column_title) &nbsp;&nbsp;
[171. Excel Sheet Column Number](src/main/java/org/example/g0101_0200/s0171_excel_sheet_column_number) &nbsp;&nbsp;
[205. Isomorphic Strings](src/main/java/org/example/g0201_0300/s0205_isomorphic_strings) &nbsp;&nbsp;
[242. Valid Аnagram](src/main/java/org/example/g0201_0300/s0242_valid_anagram) &nbsp;&nbsp;
[290. Word Pattern](src/main/java/org/example/g0201_0300/s0290_word_pattern) &nbsp;&nbsp;
[389. Find The Difference](src/main/java/org/example/g0301_0400/s0389_find_the_difference) &nbsp;&nbsp;
[392. Is Subsequence](src/main/java/org/example/g0301_0400/s0392_is_subsequence) &nbsp;&nbsp;
[680. Valid Palindrome II](src/main/java/org/example/g0601_0700/s0680_valid_palindrome_ii) &nbsp;&nbsp;
[942. DI String Match](src/main/java/org/example/g0901_1000/s0942_di_string_match) &nbsp;&nbsp;
[1668. Maximum Repeating Substring](src/main/java/org/example/g1601_1700/s1668_maximum_repeating_substring) &nbsp;&nbsp;
[2900. Longest Unequal Adjacent Groups Subsequence I](src/main/java/org/example/g2801_2900/p2900_longest_unequal_adjacent_groups_subsequence_i) &nbsp;&nbsp;
<br><br>


<b>Tree (#Tree)</b><br>
Здесь помещаем задачи, которые используют для решения различнные виды деревьев<br>
Примечания: Что такое Backtracking. Backtracking (возврат/откат) - это техника 
в программировании, когда мы: Делаем шаг вперед (добавляем элемент), 
Пробуем все возможные варианты продолжения, Возвращаемся назад (убираем последний элемент)
Пробуем другие варианты. Представьте, что вы идете по лабиринту: Идете по коридору 
(добавляете в путь) Если тупик - возвращаетесь назад (убираете из пути) Пробуете другой коридор<br>
Level Easy (#Easy)<br>
[94. Binary Tree Inorder Traversal](src/main/java/org/example/g0001_0100/s0094_binary_tree_inorder_traversal) &nbsp;&nbsp;
[100. Same Tree](src/main/java/org/example/g0001_0100/s0100_same_tree) &nbsp;&nbsp;
[101. Symmetric Tree](src/main/java/org/example/g0101_0200/s0101_symmetric_tree) &nbsp;&nbsp;
[104. Maximum Depth Of Binary Tree](src/main/java/org/example/g0101_0200/s0104_maximum_depth_of_binary_tree)&nbsp;&nbsp;
[108. Convert Sorted Array To Binary Search Tree](src/main/java/org/example/g0101_0200/s0108_convert_sorted_array_to_binary_search_tree) &nbsp;&nbsp;
[110. Balanced Binary Tree](src/main/java/org/example/g0101_0200/s0110_balanced_binary_tree) &nbsp;&nbsp;
[257. Binary Tree Paths](src/main/java/org/example/g0201_0300/s0257_binary_tree_paths) &nbsp;&nbsp;
[506. Relative Ranks](src/main/java/org/example/g0501_0600/s0506_relative_ranks) &nbsp;&nbsp;
<br><br>