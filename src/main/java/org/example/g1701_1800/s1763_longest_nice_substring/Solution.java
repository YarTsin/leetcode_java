package org.example.g1701_1800.s1763_longest_nice_substring;

// #Easy #String #HashSet #Bit_Manipulation #Sliding_Window

import java.util.HashSet;
import java.util.Set;

/**
 * 1763. Longest Nice Substring
 *
 * Строка называется "хорошей" (nice), если для каждой буквы алфавита,
 * присутствующей в ней, в строке присутствуют как ее прописная (uppercase),
 * так и строчная (lowercase) версии.
 *
 * Например:
 * "aA" - хорошая строка, потому что 'a' и 'A' присутствуют.
 * "aAbB" - хорошая строка.
 * "aAA" - не хорошая строка, потому что присутствует 'a', но нет 'A'?
 * Нет, 'A' присутствует. Это хорошая строка? Да, потому что для 'a' есть 'A',
 * и для 'A' есть 'a'.
 * "bB" - хорошая строка.
 * "Bb" - хорошая строка.
 * "c" - не хорошая строка, потому что есть 'c', но нет 'C'.
 *
 * Формулировка задачи:
 * Дана строка s. Нужно найти самую длинную подстроку строки s,
 * которая является "хорошей". Если таких подстрок несколько, нужно вернуть ту,
 * которая встречается раньше (т.е., с наименьшим начальным индексом).
 * Если "хорошей" подстроки не существует, нужно вернуть пустую строку.
 * Подстрока — это непрерывная последовательность символов исходной строки.
 * (примеры внизу)
 *
 * Решение с Set и рекурсией - 3 по скорости решение - 2 ms
 *
 *
 */
class Solution {
    public String longestNiceSubstring(String s) {
        // Вызываем рекурсивную функцию для всей строки
        return findLongestNiceSubstring(s);
    }

    // Вспомогательная рекурсивная функция для поиска самой длинной "хорошей" подстроки в строке 'str'
    private String findLongestNiceSubstring(String str) {
        // Базовый случай: подстрока слишком коротка, чтобы быть "хорошей"
        if (str.length() < 2) {
            return "";
        }

        // Создаем Set для хранения всех уникальных символов в текущей подстроке.
        // Это позволит быстро проверять наличие парных символов.
        Set<Character> charSet = new HashSet<>();
        for (char currentChar : str.toCharArray()) {
            charSet.add(currentChar);
        }

        // Проходим по каждому символу в строке 'str'
        for (int i = 0; i < str.length(); i++) {
            char currentChar = str.charAt(i);

            // Проверяем, присутствует ли в множестве парный символ (строчный для прописного и наоборот)
            // Если для текущего символа НЕТ парного, то этот символ нарушает условие "хорошести"
            if (!charSet.contains(Character.toLowerCase(currentChar)) || !charSet.contains(Character.toUpperCase(currentChar))) {
                // Найден "плохой" символ. Делим строку на части, исключая его.

                // Рекурсивно ищем самую длинную хорошую подстроку слева от плохого символа
                String leftPart = findLongestNiceSubstring(str.substring(0, i));
                // Рекурсивно ищем самую длинную хорошую подстроку справа от плохого символа
                String rightPart = findLongestNiceSubstring(str.substring(i + 1));

                // Возвращаем самую длинную из найденных подстрок.
                // Если длины равны, возвращается подстрока из leftPart, что обеспечивает приоритет по раннему вхождению.
                return (leftPart.length() >= rightPart.length()) ? leftPart : rightPart;
            }
        }

        // Если мы дошли до этого места, значит, для всех символов в 'str' нашлись парные.
        // Следовательно, вся строка 'str' является "хорошей". Возвращаем ее.
        return str;
    }
}
/*
Пример 1
Ввод: s = "YazaAay"
Вывод: "aAa"

Пример 2
Ввод: s = "Bb"
Вывод: "Bb"
Объяснение: "Bb" является хорошей строкой, поскольку 'B' и 'b' присутствуют.

Пример 3
Ввод: s = "dDzeE"
Вывод: "dD"
Объяснение:
Подстрока "dD" хорошая.
Подстрока "eE" хорошая.
Они одинаковой длины. Возвращаем ту, что встречается раньше — "dD".
Вся строка "dDzeE" не является хорошей, потому что в ней есть 'z',
для которого нет 'Z'.


 */
