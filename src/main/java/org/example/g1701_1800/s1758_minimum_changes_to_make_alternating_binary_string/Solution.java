package org.example.g1701_1800.s1758_minimum_changes_to_make_alternating_binary_string;

// #Easy #String

/**
 * 1758. Minimum Changes To Make Alternating Binary String
 *
 * Вам дана строка s, состоящая только из символов '0' и '1'.
 * Ваша цель — сделать строку чередующейся, изменив минимально
 * возможное количество символов. После операции строка должна
 * удовлетворять одному из двух условий:
 *
 * Каждый нечетный (по индексу) символ равен '1', а каждый четный
 * (по индексу) символ равен '0'.
 * Пример: "010101..."
 * Каждый нечетный (по индексу) символ равен '0', а каждый четный
 * (по индексу) символ равен '1'.
 * Пример: "101010..."
 *
 * На одном изменении можно заменить один любой символ строки
 * на противоположный ('0' на '1' или '1' на '0').
 * Требуется: вернуть минимальное количество изменений, необходимое
 * для превращения строки s в чередующуюся.
 * (примеры внизу)
 *
 * Решение - подход с одним проходом - 3 - решение - 3ms
 */
class Solution {
    public int minOperations(String s) {
        // Инициализируем счетчики изменений для двух возможных шаблонов
        int changesForPatternStartWithZero = 0; // Шаблон: '0' на четных индексах, '1' на нечетных
        int changesForPatternStartWithOne = 0;  // Шаблон: '1' на четных индексах, '0' на нечетных

        // Преобразуем строку в массив символов для более удобного обращения по индексу
        char[] characters = s.toCharArray();

        // Проходим по каждому символу строки
        for (int index = 0; index < characters.length; index++) {
            char currentChar = characters[index];

            // Проверяем для Шаблона A (startWithZero)
            // Если индекс четный, ожидаем '0', иначе ожидаем '1'
            if (index % 2 == 0) {
                if (currentChar == '1') {
                    changesForPatternStartWithZero++; // Нашли несоответствие шаблону
                }
            } else {
                if (currentChar == '0') {
                    changesForPatternStartWithZero++; // Нашли несоответствие шаблону
                }
            }

            // Проверяем для Шаблона B (startWithOne)
            // Если индекс четный, ожидаем '1', иначе ожидаем '0'
            if (index % 2 == 0) {
                if (currentChar == '0') {
                    changesForPatternStartWithOne++; // Нашли несоответствие шаблону
                }
            } else {
                if (currentChar == '1') {
                    changesForPatternStartWithOne++; // Нашли несоответствие шаблону
                }
            }
        }

        // Возвращаем минимальное количество изменений из двух рассчитанных вариантов
        return Math.min(changesForPatternStartWithZero, changesForPatternStartWithOne);
    }
}
/*
Пример 1
Ввод: s = "0100"
Вывод: 1
Объяснение:
Если мы решим, что строка должна быть "0101" (четные индексы: '0',
нечетные: '1'), то нужно изменить последний символ с '0' на '1'.
Это 1 изменение.
Если мы решим, что строка должна быть "1010" (четные индексы: '1',
нечетные: '0'), то нужно изменить первый символ с '0' на '1'.
Это тоже 1 изменение.
Минимум равен 1.

Пример 2
Ввод: s = "10"
Вывод: 0
Объяснение: Строка уже является чередующейся. Она соответствует шаблону "10".

Пример 3:
Ввод: s = "1111"
Вывод: 2
Объяснение:
Для шаблона "0101" потребуется 4 изменения (все символы не на своих местах).
Для шаблона "1010" потребуется 2 изменения (например, изменить
первый и третий символы на '0').
Минимум равен 2.
 */