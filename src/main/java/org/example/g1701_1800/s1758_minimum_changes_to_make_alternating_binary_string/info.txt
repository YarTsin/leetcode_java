Решение - подход с одним проходом

Существует всего два возможных идеальных чередующихся
шаблона для строки длины n:
Шаблон A (startWithZero): Четные индексы (i % 2 == 0) содержат '0',
нечетные индексы (i % 2 == 1) содержат '1' (например, "010101...").

Шаблон B (startWithOne): Четные индексы (i % 2 == 0) содержат '1',
нечетные индексы (i % 2 == 1) содержат '0' (например, "101010...").

Для данной строки s мы можем подсчитать, сколько символов не совпадает
с каждым из этих двух шаблонов. Количество несовпадений — это и есть
количество необходимых изменений для приведения строки к этому шаблону.

Ответом будет минимум из этих двух количеств изменений.

Подход:
Проходим по строке один раз. Для каждого индекса i:
Проверяем, какой символ должен быть в этом индексе согласно Шаблону A.
Если символ в s[i] не совпадает с ожидаемым для Шаблона A, увеличиваем
счетчик изменений для этого шаблона.
Количество изменений для Шаблона B будет равно n - changesForPatternA,
потому что если символ совпадает с Шаблоном A, он автоматически
не совпадает с Шаблоном B, и наоборот. Однако надежнее явно подсчитать
оба счетчика в цикле для ясности.