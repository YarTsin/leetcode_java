package org.example.g1701_1800.s1752_check_if_array_is_sorted_and_rotated;

// #Easy #Array

/**
 * 1752. Check if Array Is Sorted and Rotated
 *
 * Дан массив nums. Нужно проверить, был ли этот массив изначально отсортирован
 * в неубывающем порядке и затем повернут на некоторое количество позиций
 * (включая 0 поворотов).
 *
 * Массив повернут, если элементы сдвинуты циклически. Например:
 * [1,2,3,4,5] повернут на 1 позицию → [5,1,2,3,4]
 * [1,2,3,4,5] повернут на 2 позиции → [4,5,1,2,3]
 *
 * Условия:
 * Массив должен быть отсортирован в неубывающем порядке до поворота
 * После поворота в массиве может быть не более одной "точки убывания"
 * - места, где следующий элемент меньше предыдущего
 *
 * Пример 1
 * Input: nums = [3,4,5,1,2]  * Output: true
 * Объяснение: [1,2,3,4,5] повернут на 3 позиции
 *
 * Пример 2
 * Input: nums = [2,1,3,4]  * Output: false
 * Объяснение: Невозможно получить этот массив поворотом
 * отсортированного массива
 *
 * Решение с подсчетом точек убывания - самое быстрое
 *
 * Считаем количество "точек убывания" - мест, где текущий
 * элемент меньше предыдущего. В правильно повернутом отсортированном
 * массиве таких точек должно быть не более одной.
 *
 * Время: O(n) - один проход по массиву
 * Память: O(1) - не используем дополнительную память
 */
class Solution {
    public boolean check(int[] nums) {
        int decreaseCount = 0;
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            // Сравниваем текущий элемент со следующим (циклически)
            // Для последнего элемента сравниваем с первым
            if (nums[i] > nums[(i + 1) % n]) {
                decreaseCount++;
            }

            // Если найдено более одной точки убывания, массив не удовлетворяет условию
            if (decreaseCount > 1) {
                return false;
            }
        }

        return true;
    }
}
