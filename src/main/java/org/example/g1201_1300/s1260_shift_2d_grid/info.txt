Решение - Математическое вычисление позиций

Основная идея: Вместо выполнения k отдельных операций
сдвига (что было бы неэффективно для больших k),
мы можем вычислить конечную позицию каждого элемента за одну операцию.

Мы можем представить всю двумерную сетку как одномерный
массив длиной m * n. Тогда:
Сдвиг всей сетки вправо на k позиций в 2D пространстве
эквивалентен циклическому сдвигу одномерного массива вправо на k позиций.

Циклический сдвиг массива длиной L вправо на k позиций эквивалентен:
Сдвигу влево на L - k позиций
Или переносу элемента из позиции i в позицию (i + k) % L

Подход:
Получить размеры сетки: rows = m, cols = n.
Вычислить общее количество элементов: totalElements = rows * cols.
Вычислить эффективное количество сдвигов: effectiveShifts = k % totalElements.

Это оптимизация, так как сдвиг на totalElements позиций возвращает
сетку в исходное состояние.

Создать новую результирующую сетку result тех же размеров.
Для каждого элемента в исходной сетке с индексом [i][j]:

Вычислить его позицию в одномерном представлении: flatIndex = i * cols + j
Вычислить его новую позицию после сдвига: newFlatIndex = (flatIndex + effectiveShifts) % totalElements
Преобразовать новую одномерную позицию обратно в 2D координаты:
newRow = newFlatIndex / cols
newCol = newFlatIndex % cols
Поместить элемент grid[i][j] в позицию result[newRow][newCol]