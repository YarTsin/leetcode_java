package org.example.g1201_1300.s1275_find_winner_on_a_tic_tac_toe_game;

// #Easy #Array #Hash_Table #Matrix #Simulation #Bits
// #Интересно

/**
 * 1275. Find Winner on a Tic Tac Toe Game
 *
 * Дана последовательность ходов для игры в крестики-нолики на поле 3x3.
 * Массив moves содержит пары координат [row, col], где:
 * moves[i] представляет i-й ход на поле
 * Ходы чередуются: первый ход делает "A", второй - "B", третий - "A" и т.д.
 * Предполагается, что массив moves содержит только valid ходы
 * (не повторяющиеся и в пределах поля)
 * Цель: Определить результат игры после всех ходов. Возможные результаты:
 *
 * "A" - выиграл игрок A
 * "B" - выиграл игрок B
 * "Draw" - ничья (все клетки заполнены, но нет победителя)
 * "Pending" - игра не завершена (есть свободные клетки и нет победителя)
 *
 * Правила победы: Игрок побеждает, если занимает:
 * Всю строку
 * Или весь столбец
 * Или главную диагональ
 * Или побочную диагональ
 * (примеры внизу)
 *
 * Решение - Отслеживание сумм строк, столбцов и диагоналей
 * Самое быстрое - 0 ms
 *
 * Основная идея: Вместо хранения всего поля, мы можем отслеживать
 * суммы для каждого игрока в строках, столбцах и диагоналях.
 *
 * Сложность:
 * Время: O(n), где n - количество ходов
 * Память: O(1)
 *
 *
 */
public class Solution {
    public String tictactoe(int[][] moves) {
        // Массивы для отслеживания сумм по строкам и столбцам
        int[] rows = new int[3];
        int[] cols = new int[3];

        // Переменные для диагоналей
        int mainDiag = 0; // Главная диагональ: [0,0], [1,1], [2,2]
        int antiDiag = 0; // Побочная диагональ: [0,2], [1,1], [2,0]

        // Обрабатываем каждый ход
        for (int i = 0; i < moves.length; i++) {
            int row = moves[i][0];
            int col = moves[i][1];

            // Определяем значение для текущего игрока
            // A: +1, B: -1
            int value = (i % 2 == 0) ? 1 : -1;

            // Обновляем сумму для строки и столбца
            rows[row] += value;
            cols[col] += value;

            // Обновляем диагонали (если применимо)
            if (row == col) {
                mainDiag += value;
            }
            if (row + col == 2) {
                antiDiag += value;
            }

            // Проверяем условия победы
            if (Math.abs(rows[row]) == 3 ||
                    Math.abs(cols[col]) == 3 ||
                    Math.abs(mainDiag) == 3 ||
                    Math.abs(antiDiag) == 3) {

                return (value == 1) ? "A" : "B";
            }
        }

        // Проверяем статус игры после всех ходов
        if (moves.length == 9) {
            return "Draw";
        } else {
            return "Pending";
        }
    }
}
/*
Пример 1
Вход: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
Выход: "A"

Пояснение:
Ход 0: A -> [0,0]
Ход 1: B -> [2,0]
Ход 2: A -> [1,1]
Ход 3: B -> [2,1]
Ход 4: A -> [2,2]

Поле после ходов:
A| |
-----
 |A|
-----
B|B|A

Игрок A выиграл по диагонали [0,0]-[1,1]-[2,2]

==========

Пример 2
Вход: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
Выход: "B"

Пояснение:
Ход 0: A -> [0,0]
Ход 1: B -> [1,1]
Ход 2: A -> [0,1]
Ход 3: B -> [0,2]
Ход 4: A -> [1,0]
Ход 5: B -> [2,0]

Поле после ходов:
A|A|B
-----
A|B|
-----
B| |

Игрок B выиграл по диагонали [0,2]-[1,1]-[2,0]
 */