Решение - математический анализ

Основная идея: Вместо построения всей матрицы и
симуляции каждой операции (что было бы ресурсоемко
для больших n и m), мы можем отслеживать, сколько раз каждая
строка и каждый столбец были инкрементированы.
Ключевое наблюдение: значение в ячейке (i, j) равно количеству раз,
которое была инкрементирована строка i, плюс количество раз,
которое был инкрементирован столбец j. Это значение будет
нечетным только если одно из этих слагаемых четное, а другое — нечетное.


Подход:
Создаем два массива: rowCounts длиной n и colCounts длиной m,
инициализированные нулями. Они будут хранить количество операций,
примененных к каждой строке и каждому столбцу.

Проходим по массиву indices. Для каждой операции [ri, ci]:
Увеличиваем rowCounts[ri] на 1.
Увеличиваем colCounts[ci] на 1.

Теперь для каждой ячейки (i, j) итоговое значение вычисляется
как rowCounts[i] + colCounts[j].

Нам нужно посчитать, для скольких пар (i, j)
сумма rowCounts[i] + colCounts[j] является нечетной.

Пусть oddRows — количество строк, которые были инкрементированы
нечетное количество раз.
Пусть oddCols — количество столбцов, которые были инкрементированы
нечетное количество раз.

Магия: Ячейка (i, j) будет нечетной, если:
Строка i нечетная, а столбец j четный:
таких ячеек oddRows * (m - oddCols)
Строка i четная, а столбец j нечетный:
таких ячеек (n - oddRows) * oddCols
Общее количество нечетных ячеек:
oddRows * (m - oddCols) + (n - oddRows) * oddCols.

Объяснение "магии":
(Нечетное + Четное) = Нечетное
(Четное + Нечетное) = Нечетное
(Нечетное + Нечетное) = Четное
(Четное + Четное) = Четное