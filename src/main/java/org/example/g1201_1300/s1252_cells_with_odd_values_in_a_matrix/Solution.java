package org.example.g1201_1300.s1252_cells_with_odd_values_in_a_matrix;

// #Easy #Array #Math #Simulation #Matrix

/**
 * 1252. Cells with Odd Values in a Matrix
 *
 * Даны целые числа m и n - размеры матрицы,
 * и массив indices операций. Изначально все элементы
 * матрицы размером m × n равны 0.
 *
 * Каждая операция в indices[i] = [r_i, c_i] означает:
 * Увеличить все элементы в строке r_i на 1
 * Увеличить все элементы в столбце c_i на 1
 *
 * Необходимо найти количество ячеек с нечетными значениями
 * после применения всех операций.
 *
 * todo Запутанное условие
 *
 * (примеры внизу)
 *
 * Решение - математический анализ
 * Самое быстрое - 0 ms
 *
 * Сложность:
 * Время: O(n + m + k), где k - длина массива indices.
 * Мы проходим по indices один раз, а затем по массивам
 * rowCounts и colCounts для подсчета нечетных строк и столбцов.
 * Память: O(n + m) для хранения массивов rowCounts и colCounts.
 *
 *
 */
public class Solution {
    public int oddCells(int n, int m, int[][] indices) {
        // Массивы для подсчета количества операций на каждую строку и столбец
        int[] rowCounts = new int[n];
        int[] colCounts = new int[m];

        // Проходим по всем операциям в indices
        for (int[] indexPair : indices) {
            int rowIndex = indexPair[0];
            int colIndex = indexPair[1];
            // Увеличиваем счетчик для соответствующей строки
            rowCounts[rowIndex]++;
            // Увеличиваем счетчик для соответствующего столбца
            colCounts[colIndex]++;
        }

        // Подсчитываем, сколько строк было инкрементировано нечетное количество раз
        int oddRowsCount = 0;
        for (int count : rowCounts) {
            // Проверка на нечетность с помощью побитовой операции
            if ((count & 1) == 1) {
                oddRowsCount++;
            }
        }

        // Подсчитываем, сколько столбцов было инкрементировано нечетное количество раз
        int oddColsCount = 0;
        for (int count : colCounts) {
            if ((count & 1) == 1) {
                oddColsCount++;
            }
        }

        // Вычисляем общее количество нечетных ячеек
        // (Нечетная строка + Четный столбец) ИЛИ (Четная строка + Нечетный столбец)
        int totalOddCells = (oddRowsCount * (m - oddColsCount)) + ((n - oddRowsCount) * oddColsCount);

        return totalOddCells;
    }
}
/*
Пример 1 (проверить)
Input: m = 2, n = 3, indices = [[0,1],[1,1]]
Output: 5

Начальная матрица:
[0,0,0]
[0,0,0]

Шаг 1: Применяем [0,1] -> инкремент строки 0 и столбца 1
[1, 2, 1]  // Строка 0: +1, Столбец 1: +1 (ячейка [0,1] получает +2)
[0, 1, 0]  // Столбец 1: +1

Шаг 2: Применяем [1,1] -> инкремент строки 1 и столбца 1
[1, 3, 1]  // Столбец 1: +1
[1, 2, 1]  // Строка 1: +1, Столбец 1: +1 (ячейка [1,1] получает +2)

Итоговая матрица:
[1, 3, 1]
[1, 2, 1]

Нечетные значения находятся в ячейках: [0,0], [0,1], [0,2], [1,0], [1,2].
Ответ: 5

Пример 2
Вход: n = 2, m = 2, indices = [[1,1],[0,0]]
Начальная матрица:
[0,0]
[0,0]

Шаг 1: [1,1] -> [0,1], [1,2]
Шаг 2: [0,0] -> [1,0], [0,1]

Итоговая матрица:
[1, 2]
[2, 1]

Нечетные значения: [0,0] и [1,1].
Ответ: 2



 */