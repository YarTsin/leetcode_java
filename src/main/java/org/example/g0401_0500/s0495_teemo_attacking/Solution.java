package org.example.g0401_0500.s0495_teemo_attacking;

// #Easy #Array #Simulation

/**
 * 495. Teemo Attacking #Game
 *
 * В игре League of Legends есть персонаж Тимо,
 * который атакует ядовитыми дротиками.
 * Когда Тимо атакует Эша, яд наносит урон каждую секунду
 * в течение duration секунд. Однако если Тимо атакует снова
 * до окончания действия предыдущего яда, эффект яда не складывается,
 * а перезапускается (таймер сбрасывается).
 *
 * Дан целочисленный массив timeSeries, где timeSeries[i] - время в секундах,
 * когда Тимо атакует Эша, и целое число duration - длительность
 * действия яда. Необходимо вернуть общее время отравления Эша.
 *
 * Ограничения:
 * 1 <= timeSeries.length <= 10⁴
 * 0 <= timeSeries[i] <= 10⁷
 * 1 <= duration <= 10⁷
 * Массив timeSeries отсортирован в порядке возрастания
 *
 * Важные особенности:
 * Эффекты яда не складываются, а перезапускаются
 * Нужно учитывать перекрывающиеся периоды отравления
 * Массив отсортирован, что упрощает решение
 * (примеры внизу)
 *
 * Решение в один проход - не самое быстрое - 3 ms
 *
 * Объяснение подхода:
 * Обработка edge cases: Пустой массив или нулевая длительность
 * Итерация по атакам: Для каждой атаки (кроме последней) вычисляем время отравления
 * Учет перекрытия: Добавляем минимум из duration и времени до следующей атаки
 * Последняя атака: Добавляем полную duration для последней атаки
 *
 * Сложность:
 * Временная сложность: O(n) - один проход по массиву
 * Пространственная сложность: O(1)
 */
class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        if (timeSeries.length == 0) return 0;
        if (duration == 0) return 0;

        int totalPoisonedTime = 0;

        for (int i = 0; i < timeSeries.length - 1; i++) {
            // Время до следующей атаки
            int timeUntilNextAttack = timeSeries[i + 1] - timeSeries[i];

            // Добавляем duration или время до следующей атаки (если яд прерывается)
            totalPoisonedTime += Math.min(duration, timeUntilNextAttack);
        }

        // Добавляем duration для последней атаки
        totalPoisonedTime += duration;

        return totalPoisonedTime;
    }
}
/*
Пример 1
Ввод: timeSeries = [1,4], duration = 2
Вывод: 4
Объяснение:
Время 1: яд действует до времени 3 (1 + 2)
Время 4: яд действует до времени 6 (4 + 2)
Общее время: (3-1) + (6-4) = 2 + 2 = 4

Пример 2
Ввод: timeSeries = [1,2], duration = 2
Вывод: 3
Объяснение:
Время 1: яд действует до времени 3
Время 2: яд начинает действовать в время 2, но предыдущий
яд еще действует (до времени 3)
Время отравления: с 1 до 4 (2 + 2) = 3 секунды



 */