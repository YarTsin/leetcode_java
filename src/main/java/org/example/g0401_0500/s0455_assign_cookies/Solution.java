package org.example.g0401_0500.s0455_assign_cookies;

import java.util.Arrays;

/**
 * #Easy #Array #Sort #Greedy #Pointers
 * Предположим, вы родитель и хотите раздать своим детям печенье.
 * Но каждому ребенку нужно дать не больше одного печенья.
 * Каждый ребенок i имеет коэффициент жадности g[i],
 * который представляет минимальный размер печенья, которое удовлетворит
 * этого ребенка. Каждое печенье j имеет размер s[j]. Если s[j] >= g[i],
 * мы можем назначить печенье j ребенку i, и ребенок i будет удовлетворен.
 * Ваша цель - максимизировать количество удовлетворенных детей и вывести
 * это максимальное число.
 *
 * Пример 1.
 * Вход: g = [1,2,3], s = [1,1]
 * Выход: 1
 * Объяснение:
 * У вас 3 ребенка и 2 печенья. Коэффициенты жадности детей: 1, 2, 3.
 * Размеры печений: 1, 1.
 * Вы можете удовлетворить только первого ребенка, так как у вас есть только печенье размером 1.
 *
 * Пример 2.
 * Вход: g = [1,2], s = [1,2,3]
 * Выход: 2
 * Объяснение:
 * У вас 2 ребенка и 3 печенья. Коэффициенты жадности детей: 1, 2.
 * Размеры печений: 1, 2, 3.
 * Вы можете удовлетворить обоих детей, так как есть печенья размером 1 и 2.
 *
 * Оптимальное решение: жадный алгоритм с двумя указателями
 * (однако это не самое быстрое решение на литкоде 10 ms)
 */
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        // Сортируем массивы жадности детей и размеров печений
        Arrays.sort(g);
        Arrays.sort(s);

        int childIndex = 0;
        int cookieIndex = 0;
        int satisfiedChildren = 0;

        while (childIndex < g.length && cookieIndex < s.length) {
            if (s[cookieIndex] >= g[childIndex]) {
                // Нашли подходящее печенье для ребенка
                satisfiedChildren++;
                childIndex++;
                cookieIndex++;
            } else {
                // Печенье слишком маленькое, пробуем следующее
                cookieIndex++;
            }
        }

        return satisfiedChildren;
    }
}
/*
Оптимальное решение использует жадный подход:
Сортируем оба массива (детей по жадности и печенья по размеру)
Используем два указателя для сопоставления наименьшего подходящего печенья каждому ребенку
Временная сложность: O(n log n + m log m) из-за сортировки
Пространственная сложность: O(1) (или O(log n + log m) для стека рекурсии при сортировке)
 */