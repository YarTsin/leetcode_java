package org.example.g0401_0500.s0434_number_of_segments_in_a_string;

// #Easy #String

/**
 * 434. Number of Segments in a String
 * Дана строка s, необходимо вернуть количество сегментов
 * в этой строке. Сегмент определяется как последовательность
 * непробельных символов, окруженная пробелами или находящаяся
 * в начале/конце строки.
 *
 * Ограничения:
 * 0 <= s.length <= 300
 * Строка s состоит из английских букв, цифр и следующих символов: "!@#$%^&*()_+-=',.:"
 * Единственный пробельный символ в строке - это пробел ' '
 *
 * Важные особенности:
 * Пробелы в начале и конце строки не должны влиять на подсчет сегментов
 * Несколько последовательных пробелов считаются как один разделитель
 * Пустая строка должна возвращать 0
 *
 * Пример 1
 * Ввод: s = "Hello, my name is John"
 * Вывод: 5
 * Объяснение: Сегменты: "Hello,", "my", "name", "is", "John"
 *
 * Пример 2
 * Ввод: s = "Hello"
 * Вывод: 1
 *
 * Пример 3
 * Ввод: s = "   Hello,   my   name   is   John   "
 * Вывод: 5
 *
 * Решение - Однопроходный алгоритм - самый быстрый - 1 ms
 *
 * Объяснение подхода:
 * Итерация по строке: Проходим по каждому символу строки один раз
 * Определение начала сегмента: Сегмент начинается, когда:
 * Текущий символ НЕ пробел
 * И (это первый символ ИЛИ предыдущий символ был пробелом)
 * Подсчет: Увеличиваем счетчик при обнаружении начала нового сегмента
 *
 * Сложность:
 * Временная сложность: O(n), где n - длина строки
 * Пространственная сложность: O(1)
 */
class Solution {
    public int countSegments(String s) {
        int segmentCount = 0;

        for (int i = 0; i < s.length(); i++) {
            // Проверяем, является ли текущий символ непробельным И
            // (это первый символ ИЛИ предыдущий символ был пробелом)
            if ((i == 0 || s.charAt(i - 1) == ' ') && s.charAt(i) != ' ') {
                segmentCount++;
            }
        }

        return segmentCount;
    }
}