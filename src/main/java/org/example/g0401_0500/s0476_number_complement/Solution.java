package org.example.g0401_0500.s0476_number_complement;

// #Easy #Bit_Manipulation #Bit_Mask #XOR

/**
 * 476. Number Complement
 *
 * todo возможно добавить  метку побитовый сдвиг
 * Дополнение целого числа - это операция, которая инвертирует
 * все биты в его бинарном представлении
 * Однако при этом ведущие нули в бинарном представлении не
 * инвертируются. Дано целое число num, вернуть его дополнение.
 *
 * Ограничения:
 * 1 <= num < 2³¹
 * Важные особенности:
 * Ведущие нули не инвертируются (рассматривается только значимая часть числа)
 * Для числа 5 (101) дополнение будет 2 (010)
 * Нужно найти битовую маску, покрывающую только значимые биты
 * (примеры внизу)
 *
 * Решение - битовая маска
 *
 * Объяснение подхода:
 * Определяем длину числа: Находим количество значимых битов
 * Создаем маску: Маска из единиц той же длины, что и значимые биты
 * Инвертируем и маскируем: Инвертируем все биты и применяем маску
 * чтобы убрать ведущие единицы
 *
 * Сложность:
 * Временная сложность: O(1) - фиксированное количество операций
 * Пространственная сложность: O(1)
 *
 * это самое быстрое решение - 0 ms
 *
 */
class Solution {
    public int findComplement(int num) {
        // Находим количество значимых битов
        int numBits = Integer.SIZE - Integer.numberOfLeadingZeros(num);

        // Создаем маску из единиц той же длины, что и значимые биты num
        int mask = (1 << numBits) - 1;

        // Инвертируем биты и применяем маску
        return ~num & mask;
    }
}
/*
Пример 1
Ввод: num = 5
Вывод: 2
Объяснение:
5 в binary: 101
Дополнение: 010 = 2

Пример 2
Ввод: num = 1
Вывод: 0
Объяснение:
1 в binary: 1
Дополнение: 0

Пример 3
Ввод: num = 7
Вывод: 0
Объяснение:
7 в binary: 111
Дополнение: 000 = 0

Пример 4
Ввод: num = 10
Вывод: 5
Объяснение:
10 в binary: 1010
Дополнение: 0101 = 5

 */
