package org.example.g0401_0500.s0448_find_all_numbers_disappeared_in_an_array;

// #Easy #Array #Hash_Table

import java.util.ArrayList;
import java.util.List;

/**
 * 448. Find All Numbers Disappeared in an Array
 * Дан массив nums длины n, где nums[i] находится в диапазоне [1, n].
 * Необходимо вернуть массив всех чисел в диапазоне [1, n],
 * которые отсутствуют в данном массиве.
 *
 * Ограничения:
 * n == nums.length
 * 1 <= n <= 10⁵
 * 1 <= nums[i] <= n
 *
 * Важные особенности:
 * Массив может содержать дубликаты
 * Решение должно работать за O(n) времени и использовать O(1)
 * дополнительной памяти (кроме возвращаемого массива)
 * Можно модифицировать исходный массив
 *
 * Пример 1
 * Ввод: nums = [4,3,2,7,8,2,3,1]
 * Вывод: [5,6]
 * Объяснение: Числа 5 и 6 отсутствуют в массиве
 *
 * Пример 2
 * Ввод: nums = [1,1]
 * Вывод: [2]
 *
 * Пример 3
 * Ввод: nums = [1,2,3,4,5]
 * Вывод: []
 *
 * Решение - маркировка на месте - это не самое быстрое решение - 6 ms
 */
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> result = new ArrayList<>();

        // Первый проход: маркируем присутствующие числа
        for (int i = 0; i < nums.length; i++) {
            // Берем абсолютное значение, так как число могло быть уже отмечено отрицательным
            int index = Math.abs(nums[i]) - 1;

            // Если число положительное, отмечаем его как присутствующее
            if (nums[index] > 0) {
                nums[index] = -nums[index];
            }
        }

        // Второй проход: находим неотмеченные индексы
        for (int i = 0; i < nums.length; i++) {
            // Если число положительное, значит индекс (i+1) отсутствует
            if (nums[i] > 0) {
                result.add(i + 1);
            }
        }

        return result;
    }
}

/*
Объяснение подхода:
Маркировка на месте: Используем знак чисел для отметки присутствующих элементов
Первый проход: Для каждого числа nums[i] отмечаем элемент с индексом nums[i]-1 как отрицательный
Второй проход: Ищем положительные числа - их индексы + 1 будут отсутствующими числами

Сложность:
Временная сложность: O(n) - два прохода по массиву
Пространственная сложность: O(1) - кроме возвращаемого списка
 */
