package org.example.g0401_0500.s0414_third_maximum_number;


/**
 * Дан целочисленный массив nums. Необходимо вернуть третье
 * по величине максимальное число в этом массиве.
 * Если третьего максимума не существует,
 * следует вернуть максимальное число.
 *
 * Особые условия:
 * Если в массиве есть дубликаты, они должны
 * учитываться как одно значение. Например, в массиве
 * [2, 2, 3, 1] третье максимальное число - это 1, так как два
 * максимальных числа - это 3 и 2 (вторая двойка игнорируется).
 *
 * Если в массиве менее трех уникальных чисел, нужно вернуть максимальное число.
 *
 * Пример 1
 * Вход: nums = [3, 2, 1]
 * Выход: 1
 * Объяснение: Первые три максимальных числа - 3, 2 и 1.
 *
 * Пример 2
 * Вход: nums = [1, 2]
 * Выход: 2
 * Объяснение: Третьего максимального числа не существует,
 * поэтому возвращаем максимальное - 2.
 *
 * Вход: nums = [2, 2, 3, 1]
 * Выход: 1
 * Объяснение: Первые три уникальных максимальных числа - 3, 2 и 1.
 *
 * Оптимальное решение - использование трех переменных
 */
class Solution {
    public int thirdMax(int[] nums) {
        // Инициализируем переменные минимальным значением для типа long,
        // чтобы корректно обрабатывать случаи с Integer.MIN_VALUE
        long firstMax = Long.MIN_VALUE;
        long secondMax = Long.MIN_VALUE;
        long thirdMax = Long.MIN_VALUE;

        for (int num : nums) {
            // Пропускаем дубликаты
            if (num == firstMax || num == secondMax || num == thirdMax) {
                continue;
            }

            if (num > firstMax) {
                thirdMax = secondMax;
                secondMax = firstMax;
                firstMax = num;
            } else if (num > secondMax) {
                thirdMax = secondMax;
                secondMax = num;
            } else if (num > thirdMax) {
                thirdMax = num;
            }
        }

        // Если третьего максимума нет, возвращаем первый
        return (thirdMax != Long.MIN_VALUE) ? (int) thirdMax : (int) firstMax;
    }
}