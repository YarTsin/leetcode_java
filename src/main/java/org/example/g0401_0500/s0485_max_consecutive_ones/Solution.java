package org.example.g0401_0500.s0485_max_consecutive_ones;

// #Easy #Array

/**
 * Дан бинарный массив nums, состоящий из 0 и 1.
 * Необходимо найти максимальное количество подряд
 * идущих единиц в этом массиве.
 *
 * Ограничения:
 * 1 <= nums.length <= 10⁵
 * nums[i] может быть 0 или 1
 *
 * Важные особенности:
 * Массив содержит только 0 и 1
 * Нужно найти самую длинную последовательность единиц
 * Последовательность должна быть непрерывной
 *
 * Пример
 * Ввод: nums = [1,1,0,1,1,1]
 * Вывод: 3
 * Объяснение: Первые две единицы или последние три единицы → максимально 3
 *
 * Решение - в один проход с двумя указателями
 * не самое быстрое решение - 3 ms
 */
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int maxCount = 0;
        int currentCount = 0;

        for (int num : nums) {
            if (num == 1) {
                currentCount++;
                maxCount = Math.max(maxCount, currentCount);
            } else {
                currentCount = 0;
            }
        }

        return maxCount;
    }
}
/*
Объяснение подхода:
Инициализация счетчиков: maxCount для хранения максимальной длины,
currentCount для текущей последовательности

Итерация по массиву: Для каждого элемента:
Если 1: увеличиваем currentCount и обновляем maxCount
Если 0: сбрасываем currentCount
Возврат результата: maxCount содержит максимальную длину последовательности

Сложность:
Временная сложность: O(n) - один проход по массиву
Пространственная сложность: O(1) - константная память
 */
