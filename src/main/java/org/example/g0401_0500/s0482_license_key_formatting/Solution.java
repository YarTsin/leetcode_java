package org.example.g0401_0500.s0482_license_key_formatting;

// #Easy #String

/**
 * 482. License Key Formatting
 *
 * Вам дана строка s, представляющая лицензионный ключ,
 * и целое число k. Задача - отформатировать строку так,
 * чтобы каждая группа содержала ровно k символов, кроме первой группы,
 * которая может быть короче, но должна содержать хотя бы один символ.
 * Кроме того, все буквы должны быть преобразованы в верхний регистр,
 * а между группами должны быть вставлены дефисы.
 *
 * Ограничения:
 * 1 <= s.length <= 10⁵
 * s состоит из английских букв, цифр и дефисов '-'
 * 1 <= k <= 10⁴
 *
 * Важные особенности:
 * Нужно удалить все существующие дефисы
 * Преобразовать все буквы в верхний регистр
 * Разбить на группы по k символов (первая группа может быть короче)
 * Вставить дефисы между группами
 *
 * Пример 1
 * Ввод: s = "5F3Z-2e-9-w", k = 4
 * Вывод: "5F3Z-2E9W"
 * Объяснение: Удаляем дефисы → "5F3Z2E9W", разбиваем на группы по 4: "5F3Z-2E9W"
 *
 * Пример 2
 * Ввод: s = "2-5g-3-J", k = 2
 * Вывод: "2-5G-3J"
 * Объяснение: Удаляем дефисы → "25G3J", разбиваем на группы по 2: "2-5G-3J"
 *
 * Решение - обратный проход
 * Это не самое быстрое решение - 10 ms
 */
class Solution {
    public String licenseKeyFormatting(String s, int k) {
        StringBuilder result = new StringBuilder();
        int count = 0;

        // Проходим с конца строки к началу
        for (int i = s.length() - 1; i >= 0; i--) {
            char currentChar = s.charAt(i);

            // Пропускаем дефисы
            if (currentChar == '-') {
                continue;
            }

            // Добавляем дефис после каждой k-ой буквы (кроме самой первой)
            if (count > 0 && count % k == 0) {
                result.append('-');
            }

            // Добавляем символ в верхнем регистре
            result.append(Character.toUpperCase(currentChar));
            count++;
        }

        // Разворачиваем результат, так как добавляли с конца
        return result.reverse().toString();
    }
}

/*
Объяснение подхода:
Обратный проход: Обрабатываем строку с конца для удобства вставки дефисов
Пропуск дефисов: Игнорируем существующие дефисы
Вставка дефисов: Добавляем дефис после каждых k символов
Верхний регистр: Преобразуем все символы к верхнему регистру
Реверс результата: Так как добавляли с конца, нужно развернуть строку

Сложность:
Временная сложность: O(n) - один проход по строке
Пространственная сложность: O(n) - для хранения результата
 */
