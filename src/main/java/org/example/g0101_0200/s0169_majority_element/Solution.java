package org.example.g0101_0200.s0169_majority_element;

// #Easy #Top_100_Liked_Questions #Top_Interview_Questions #Array #Hash_Table #Sorting #Counting
// #Divide_and_Conquer
// #Top_Interview_150_Array/String

/**
 * 169. Majority Element
 *
 * Дан массив nums размера n. Нужно найти "мажоритарный элемент"
 * - элемент, который встречается более (n/2) раз.
 * Можно считать, что мажоритарный элемент всегда существует в массиве.
 *
 * Лучшее решение использует алгоритм Бойера-Мура для поиска большинства,
 * который работает за O(n) времени и O(1) памяти.
 *
 * Идея алгоритма: мы "голосуем" за кандидата, увеличивая счетчик,
 * когда видим его, и уменьшая, когда видим другой элемент.
 * Если счетчик становится нулевым, мы выбираем новый кандидат.
 * В конце у нас останется элемент, который встречается чаще всего.
 *
 * Почему это работает:
 * Если есть элемент, который встречается более чем n/2 раз,
 * другие элементы не смогут "перевесить" его в процессе голосования.
 * Даже если счетчик уменьшается при встрече других элементов,
 * у мажоритарного элемента достаточно "силы", чтобы остаться в конце.
 *
 * todo доделать
 */
class Solution {
    public int majorityElement(int[] nums) {
        // Инициализируем кандидата и счетчик
        int candidate = nums[0];
        int count = 1;

        // Проходим по всем элементам массива
        for (int i = 1; i < nums.length; i++) {
            if (count == 0) {
                // Если счетчик нулевой, выбираем нового кандидата
                candidate = nums[i];
                count = 1;
            } else if (candidate == nums[i]) {
                // Если текущий элемент совпадает с кандидатом, увеличиваем счетчик
                count++;
            } else {
                // Иначе уменьшаем счетчик
                count--;
            }
        }

        // В конце candidate будет мажоритарным элементом
        return candidate;
    }
}