Объяснение подходов
Алгоритм Брайана Кернигана (самый эффективный)
Принцип работы:
Инициализация: Начинаем с счетчика 0
Итерация: Пока число не равно 0
Увеличение счетчика: Увеличиваем счетчик на 1
Удаление младшего бита: n = n & (n - 1) удаляет младший установленный бит


Магическая операция n & (n - 1):
n - 1 инвертирует все биты после младшего установленного бита
n & (n - 1) обнуляет только младший установленный бит
Пример: n = 12 (1100), n-1 = 11 (1011), n & (n-1) = 8 (1000)


Решение с побитовым сдвигом
Принцип работы:
Проверка битов: Последовательно проверяем все 32 бита
Проверка младшего бита: n & 1 проверяет установлен ли младший бит
Сдвиг числа: n >>>= 1 сдвигает биты вправо (беззнаковый сдвиг)


Встроенная функция Java
Integer.bitCount(n) использует highly optimized native implementation
Обычно это самый быстрый вариант на практике


Преимущества алгоритма Кернигана:
Работает только с установленными битами (не проверяет нулевые биты)
В среднем быстрее для чисел с малым количеством установленных битов
Элегантная и эффективная математика


Ключевые моменты:
Важно использовать беззнаковый сдвиг >>> вместо знакового >>
В Java необходимо обрабатывать int как беззнаковое число
Алгоритм гарантированно обрабатывает все 32 бита корректно


Сравнение производительности:
Алгоритм Кернигана: лучше для чисел с малым количеством единиц
Побитовый сдвиг: стабильное время выполнения (всегда 32 итерации)
Встроенная функция: обычно самая быстрая (использует оптимизированный нативный код)