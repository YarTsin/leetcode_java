Объяснение подходов
Основное решение (побитовые сдвиги)
Принцип работы:
Инициализация: Начинаем с результата 0
Итерация по битам: Обрабатываем все 32 бита входного числа
Сдвиг результата: Освобождаем младший бит результата для нового бита
Извлечение бита: Берем младший бит входного числа
Добавление бита: Помещаем извлеченный бит в результат
Сдвиг входного числа: Переходим к следующему биту

Ключевые моменты:
Используем >>> (беззнаковый сдвиг вправо) вместо >> (знаковый сдвиг)
Работаем с числом как с беззнаковым, несмотря на знаковый тип Java

Решение с кэшированием
Принцип работы:
Предварительное вычисление: Заранее вычисляем обращенные значения для всех байтов (0-255)
Разбиение на байты: Делим 32-битное число на 4 байта
Поиск в кэше: Для каждого байта находим обращенное значение в кэше
Сборка результата: Собираем результат из обращенных байтов

Преимущества:
Быстрее при многократных вызовах (например, в тестовых сценариях)
Всего 4 операции вместо 32

Недостатки:
Требует дополнительной памяти для кэша
Сложнее в реализации

Преимущества основного подхода:
Простота и понятность
Не требует дополнительной памяти
Легко модифицируется для других разрядностей
Оптимально для однократного использования
Оба решения корректны и принимаются leetcode.
Основное решение предпочтительнее для большинства случаев благодаря
своей простоте и отсутствию дополнительных требований к памяти.