Пошаговое объяснение
Инициализация:
- Создаем StringBuilder для эффективного построения строки

Основной цикл:
- Работает, пока columnNumber больше 0
- columnNumber--: Корректируем число, так как 'A' соответствует 1, а не 0

Определение текущего символа:
- columnNumber % 26 дает позицию символа в алфавите (0-25)
- 'A' + остаток преобразуется в соответствующий символ

Добавление символа:
- Вставляем символ в начало строки (так как обрабатываем младшие разряды первыми)

Обновление числа:
- Делим columnNumber на 26 для перехода к следующему разряду

Завершение:
- Когда columnNumber становится 0, возвращаем собранную строку

===========

Примеры работы
Для columnNumber = 1:
1-1=0 → 'A'
Результат: "A"

Для columnNumber = 28:
Первая итерация: 28-1=27 → 27%26=1 → 'B', число=27/26=1
Вторая итерация: 1-1=0 → 'A'
Результат: "AB"

Для columnNumber = 701:
Первая итерация: 701-1=700 → 700%26=24 → 'Y', число=700/26=26
Вторая итерация: 26-1=25 → 'Z', число=26/26=1
Третья итерация: 1-1=0 → 'A'
Результат: "ZY"

=================

Особенности реализации
Коррекция числа:
- columnNumber-- перед вычислением символа - ключевой момент решения
- Позволяет правильно обрабатывать 'Z' (остаток 0)

Эффективность:
Временная сложность: O(log₂₆(n)) - количество цифр в 26-ричном представлении
Пространственная сложность: O(log₂₆(n)) для хранения результата

Обработка граничных случаев:
- Работает с минимальным (1) и максимальным (Integer.MAX_VALUE) значениями
- Корректно обрабатывает переходы через 'Z'

============

