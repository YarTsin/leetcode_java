Подходы к решению
1. Наивное решение (два вложенных цикла)
Проверяем все возможные пары дней (покупка/продажа) и находим максимальную разницу.

2. Оптимальное решение (один проход)
Отслеживаем минимальную цену и максимальную прибыль за один проход.

============

Временная сложность
O(n) - где n это количество дней (длина массива prices). Мы делаем только один проход по массиву.

Пространственная сложность
O(1) - используем только константное количество дополнительной памяти (две переменные).

===========
Альтернативное решение (Kadane's Algorithm)

public class Solution {
    public int maxProfit(int[] prices) {
        int maxCur = 0, maxSoFar = 0;
        for (int i = 1; i < prices.length; i++) {
            maxCur = Math.max(0, maxCur + prices[i] - prices[i-1]);
            maxSoFar = Math.max(maxSoFar, maxCur);
        }
        return maxSoFar;
    }
}

Этот подход основан на алгоритме Кадане для
поиска максимального подмассива, адаптированном для данной задачи.

==============

Дополнительные вопросы для собеседования
1. Как изменить решение, если нужно найти не максимальную прибыль, а дни покупки и продажи?
Нужно дополнительно отслеживать индексы минимальной цены и максимальной прибыли

2. Как решить задачу, если можно совершать несколько сделок?
Это уже задача 122 (Best Time to Buy and Sell Stock II),
где можно суммировать все возрастающие разницы

3. Что если добавить комиссию за сделку?
Нужно учитывать комиссию при расчете прибыли (задача 714)

4. Как изменится решение, если между покупкой и продажей
должен быть как минимум 1 день охлаждения?
Это задача 309 (Best Time to Buy and Sell Stock with Cooldown),
требующая более сложного подхода

=============
Вариации задачи
Best Time to Buy and Sell Stock II (неограниченное количество сделок)
Best Time to Buy and Sell Stock III (максимум 2 сделки)
Best Time to Buy and Sell Stock IV (максимум k сделок)
Best Time to Buy and Sell Stock with Cooldown
Best Time to Buy and Sell Stock with Transaction Fee