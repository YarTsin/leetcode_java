package org.example.g0901_1000.s0942_di_string_match;

/**
 * #Easy #Array #String #Math #Greedy #Pointers
 *
 * Условие: Дана строка s, состоящая только из символов
 * 'I' (increase) и 'D' (decrease). Нужно вернуть любую
 * перестановку [0, 1, 2, ..., n] длины n + 1, такую что для
 * всех i в диапазоне [0, n - 1]:
 *
 * Если s[i] == 'I', то perm[i] < perm[i + 1]
 * Если s[i] == 'D', то perm[i] > perm[i + 1]
 *
 * Пример 1  * Input: s = "IDID"  * Output: [0,4,1,3,2]
 * Объяснение:
 * s[0] = 'I' → 0 < 4 ✓
 * s[1] = 'D' → 4 > 1 ✓
 * s[2] = 'I' → 1 < 3 ✓
 * s[3] = 'D' → 3 > 2 ✓
 *
 * Пример 2 * Input: s = "III" * Output: [0,1,2,3]
 * Объяснение: Все три 'I' требуют возрастания
 *
 * Input: s = "DDI"
 * Output: [3,2,0,1] или [2,1,0,3] и т.д.
 * Объяснение:
 * s[0] = 'D' → 3 > 2 или 2 > 1 ✓
 * s[1] = 'D' → 2 > 0 или 1 > 0 ✓
 * s[2] = 'I' → 0 < 1 или 0 < 3 ✓
 *
 * todo запутанное условие возможно надо больше тестов
 * Оптимальное решение: 2 указателя - 3 по скорости решение - 2 ms
 */
public class Solution {
    public int[] diStringMatch(String s) {
        int n = s.length();
        int[] result = new int[n + 1];
        int low = 0;    // Минимальное доступное число
        int high = n;   // Максимальное доступное число

        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == 'I') {
                // Для 'I' берем минимальное число (гарантируем возрастание)
                result[i] = low++;
            } else { // s.charAt(i) == 'D'
                // Для 'D' берем максимальное число (гарантируем убывание)
                result[i] = high--;
            }
        }

        // Последний элемент - оставшееся число
        result[n] = low; // или high (они равны в этот момент)

        return result;
    }
}
/*
Подход: Два указателя. Используем минимальное и максимальное
доступные числа. Для 'I' берем минимальное доступное число,
для 'D' - максимальное.

Сложность: O(n) - один проход по строке
Память: O(1) дополнительной памяти (кроме результата)
 */