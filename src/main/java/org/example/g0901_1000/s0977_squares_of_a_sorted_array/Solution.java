package org.example.g0901_1000.s0977_squares_of_a_sorted_array;

// #Easy #Array #Sorting #Two_Pointers #PriorityQueue

/**
 * 977. Squares of a Sorted Array
 * Дан целочисленный массив nums, отсортированный в порядке неубывания.
 * Верните массив квадратов каждого числа, также отсортированный
 * в порядке неубывания.
 *
 * Пример 1
 * Вход: nums = [-4,-1,0,3,10]
 * Выход: [0,1,9,16,100]
 * Объяснение:
 * После возведения в квадрат: [16,1,0,9,100]
 * После сортировки: [0,1,9,16,100]
 *
 * Пример 2
 * Вход: nums = [-7,-3,2,3,11]
 * Выход: [4,9,9,49,121]
 * Объяснение:
 * После возведения в квадрат: [49,9,4,9,121]
 * После сортировки: [4,9,9,49,121]
 *
 * Особенности задачи:
 * Массив может содержать отрицательные числа
 * После возведения в квадрат отрицательные числа становятся положительными
 * Исходный массив отсортирован, но квадраты могут быть не отсортированы
 * из-за отрицательных чисел
 *
 * Решение: использование 2 указателя - самое быстрое 0 ms
 *
 * Подход:
 * Используем два указателя. Так как исходный массив отсортирован,
 * наибольшие квадраты будут находиться по краям массива
 * (из-за отрицательных чисел). Будем двигаться от краев к центру,
 * сравнивая абсолютные значения и заполняя результирующий массив с конца.
 *
 * Временная сложность: O(n) - один проход по массиву
 * Пространственная сложность: O(n) - для результирующего массива
 *
 */
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];

        // Указатели на начало и конец исходного массива
        int left = 0;
        int right = n - 1;

        // Указатель для заполнения результирующего массива (с конца)
        int index = n - 1;

        while (left <= right) {
            int leftSquare = nums[left] * nums[left];
            int rightSquare = nums[right] * nums[right];

            // Выбираем больший квадрат и помещаем в конец результата
            if (leftSquare > rightSquare) {
                result[index] = leftSquare;
                left++; // Перемещаем левый указатель
            } else {
                result[index] = rightSquare;
                right--; // Перемещаем правый указатель
            }
            index--; // Перемещаем указатель результата
        }

        return result;
    }
}
