package org.example.g0901_1000.s0976_largest_perimeter_triangle;

import java.util.Arrays;

/**
 * #Easy #Array #Math #Sort #Greedy
 * Условие: Дан массив положительных целых чисел nums.
 * Нужно вернуть наибольший периметр треугольника, который можно
 * образовать из трех элементов массива. Если невозможно образовать
 * ни одного треугольника, вернуть 0.
 *
 * Треугольник существует если выполняется неравенство треугольника:
 * сумма любых двух сторон должна быть больше третьей стороны.
 *
 * Задача: Найти три числа, которые могут быть сторонами
 * треугольника с максимальным периметром.
 *
 * Пример 1  * Input: nums = [2,1,2]  * Output: 5
 * Объяснение: Стороны 2, 2, 1 → 2 + 1 > 2, 2 + 2 > 1, 1 + 2 > 2 ✓
 * Периметр = 2 + 2 + 1 = 5
 *
 * Пример 2  * Input: nums = [1,2,1]  * Output: 0
 * Объяснение: 1 + 1 = 2 → не выполняется неравенство треугольника
 *
 * Пример 3  * Input: nums = [3,2,3,4]  * Output: 10
 * Объяснение: Стороны 3, 3, 4 → 3 + 3 > 4, 3 + 4 > 3, 3 + 4 > 3 ✓
 * Периметр = 3 + 3 + 4 = 10
 *
 * Оптимальное решение: сортировка + жадный алгоритм
 * не самое быстрое решение - 8 ms
 */
public class Solution {
    public int largestPerimeter(int[] nums) {
        // Сортируем массив в порядке возрастания
        Arrays.sort(nums);

        // Проходим с конца массива, ищем первую валидную тройку
        for (int i = nums.length - 1; i >= 2; i--) {
            int sideA = nums[i];
            int sideB = nums[i - 1];
            int sideC = nums[i - 2];

            // Проверяем неравенство треугольника
            if (sideB + sideC > sideA) {
                return sideA + sideB + sideC;
            }
        }

        return 0; // Не найдено валидных треугольников
    }
}

/*
Оптимальное решение
Подход: Сортировка + жадный алгоритм. Сортируем массив и
проверяем тройки с конца (наибольшие числа).

Сложность: O(n log n) - из-за сортировки
Память: O(1) или O(log n) в зависимости от реализации сортировки
 */
