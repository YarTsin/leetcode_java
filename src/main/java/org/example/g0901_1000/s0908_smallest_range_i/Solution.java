package org.example.g0901_1000.s0908_smallest_range_i;

// #Easy #Array #Math

/**
 * 908. Smallest Range I
 *
 * Дан массив целых чисел nums и целое число k.
 * Для каждого элемента nums[i] можно выполнить одну из следующих операций:
 * Увеличить значение на x, где x ∈ [-k, k]
 * Или не изменять значение
 *
 * Необходимо найти минимально возможную разницу между максимальным
 * и минимальным элементами массива после выполнения операций.
 *
 * Проще говоря: Мы можем изменять каждый элемент в пределах ±k.
 * Нужно сделать массив как можно более "плотным" и найти минимальную
 * возможную разницу между max и min.
 *
 * Пример 1
 * Вход: nums = [1], k = 0
 * Выход: 0
 * Объяснение: Массив из одного элемента, разница всегда 0
 *
 * Пример 2
 * Вход: nums = [0,10], k = 2
 * Выход: 6
 * Объяснение:
 * - Можно изменить 0 до 2, а 10 до 8
 * - Массив становится [2,8], разница = 6
 *
 * Пример 3
 * Вход: nums = [1,3,6], k = 3
 * Выход: 0
 * Объяснение:
 * - Можно изменить все элементы к среднему значению
 * - 1 → 4, 3 → 4, 6 → 4
 * - Массив становится [4,4,4], разница = 0
 *
 * Решение: Математический анализ минимальной и
 * максимальной возможной разницы
 * Не быстро - 3 ms
 *
 * Сложность:
 * Временная: O(N), где N - длина массива
 * Пространственная: O(1)
 */
class Solution {
    public int smallestRangeI(int[] nums, int k) {
        // Находим минимальный и максимальный элементы в массиве
        int min = nums[0];
        int max = nums[0];

        for (int num : nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }

        // Вычисляем исходную разницу
        int originalDiff = max - min;

        // Мы можем уменьшить разницу максимум на 2k
        // (поднять минимум на k и опустить максимум на k)
        int reducedDiff = originalDiff - 2 * k;

        // Если reducedDiff отрицательный, значит можем сделать разницу 0
        return Math.max(0, reducedDiff);
    }
}
