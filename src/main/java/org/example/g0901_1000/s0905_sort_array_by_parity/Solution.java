package org.example.g0901_1000.s0905_sort_array_by_parity;

// #Easy #Array #Sorting #Two_Pointers

/**
 * 905. Sort Array By Parity
 *
 * Дан массив целых неотрицательных чисел nums.
 * Необходимо отсортировать массив так, чтобы все четные числа
 * находились в начале массива, а все нечетные - в конце.
 * Относительный порядок четных и нечетных чисел может быть любым.
 *
 * Пример 1
 * Вход: [3,1,2,4]
 * Выход: [2,4,3,1] или [4,2,3,1] или [2,4,1,3] или [4,2,1,3]
 * Объяснение: Все четные числа (2,4) в начале, нечетные (3,1) в конце.
 *
 * Пример 2
 * Вход: [1,2,3,4,5,6]
 * Выход: [2,4,6,1,3,5] или любой другой валидный вариант
 *
 * Оптимальное решение - два указателя - 0 ms
 *
 */
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int left = 0;  // Указатель для четных чисел
        int right = nums.length - 1;  // Указатель для нечетных чисел

        while (left < right) {
            // Ищем нечетное число слева
            if (nums[left] % 2 == 1) {
                // Ищем четное число справа
                if (nums[right] % 2 == 0) {
                    // Меняем местами нечетное слева и четное справа
                    int temp = nums[left];
                    nums[left] = nums[right];
                    nums[right] = temp;
                    left++;
                }
                right--;
            } else {
                left++;  // Число уже четное, двигаемся дальше
            }
        }

        return nums;
    }
}
/*
Два указателя:
left - начинает с начала массива, ищет нечетные числа
right - начинает с конца массива, ищет четные числа

Логика обмена:
Если находим нечетное число слева и четное справа - меняем их местами
Если число слева уже четное - просто двигаем указатель
Если число справа нечетное - двигаем указатель справа

Временная сложность: O(n) - один проход по массиву
Пространственная сложность: O(1) - сортировка на месте
 */
