package org.example.g1801_1900.s1827_minimum_operations_to_make_the_array_increasing;

// #Easy #Array #Greedy

/**
 * 1827. Minimum Operations to Make the Array Increasing
 *
 * Дан целочисленный массив nums. За одну операцию вы можете выбрать
 * один элемент и увеличить его значение на 1.
 * Найти минимальное количество операций, необходимое для того,
 * чтобы массив стал строго возрастающим.
 *
 * Важные уточнения:
 * Строго возрастающий означает, что каждый следующий элемент
 * должен быть строго больше предыдущего: nums[i] < nums[i+1] для всех допустимых i.
 * Можно увеличивать значение любого элемента на любое количество
 * раз (каждая инкрементация считается за одну операцию).
 *
 * Нельзя уменьшать значение элемента.
 * (примеры внизу)
 *
 * Решение - жадный алгоритм - 5-е решение -
 *
 * Сложность:
 * Время: O(n), где n - длина массива. Мы проходим
 * по массиву всего один раз.
 * Пространство: O(1). Мы используем только постоянное
 * количество дополнительной памяти (переменные).
 *
 */
class Solution {
    public int minOperations(int[] nums) {
        // Если в массиве 0 или 1 элемент, он уже считается строго возрастающим.
        if (nums.length <= 1) {
            return 0;
        }

        // Счетчик минимального количества операций.
        int operationsCount = 0;

        // Начинаем обход со второго элемента (индекс 1).
        for (int currentIndex = 1; currentIndex < nums.length; currentIndex++) {
            // Индекс предыдущего элемента.
            int previousIndex = currentIndex - 1;

            // Проверяем, нарушено ли условие строгого возрастания.
            // Текущий элемент должен быть БОЛЬШЕ предыдущего.
            if (nums[currentIndex] <= nums[previousIndex]) {

                // Вычисляем минимальное значение, которое должен иметь текущий элемент,
                // чтобы массив стал строго возрастающим на этом шаге.
                // Это значение должно быть на 1 больше, чем предыдущий элемент.
                int requiredValueForCurrentElement = nums[previousIndex] + 1;

                // Вычисляем, насколько нужно увеличить текущий элемент.
                int operationsNeeded = requiredValueForCurrentElement - nums[currentIndex];

                // Добавляем необходимое количество операций к общему счетчику.
                operationsCount += operationsNeeded;

                // КРИТИЧЕСКИ ВАЖНЫЙ ШАГ:
                // Мы "обновляем" текущий элемент в массиве до требуемого значения.
                // Это не меняет исходные данные, но гарантирует, что при сравнении
                // следующего элемента мы будем отталкиваться от правильного (нового) значения.
                nums[currentIndex] = requiredValueForCurrentElement;
            }
            // Если условие строгого возрастания не нарушено (nums[i] > nums[i-1]),
            // просто переходим к следующей итерации, не делая ничего.
        }

        return operationsCount;
    }
}
/*
Пример 1
Вход: nums = [1, 1, 1]
Объяснение: Массив не является строго возрастающим.
Чтобы nums[1] > nums[0], мы можем увеличить nums[1] на 1.
Массив становится [1, 2, 1]. Операций: 1.
Теперь nums[2] (равный 1) должен быть больше nums[1] (равного 2).
Мы должны увеличить nums[2] до как минимум 3. Увеличиваем его на 2.
Массив становится [1, 2, 3]. Операций: 2.
Общее количество операций: 1 + 2 = 3.
Выход: 3

Пример 2
Вход: nums = [1, 5, 2, 4, 1]
Объяснение:
nums[0] = 1, nums[1] = 5 -> условие 5 > 1 выполняется. Операций: 0.
nums[2] = 2 должен быть больше nums[1] = 5. Чтобы это исправить,
            nums[2] должен стать как минимум 6. Увеличиваем его на 4. Операций: 4. Теперь nums[2] = 6.
nums[3] = 4 должен быть больше nums[2] = 6.
            Он должен стать как минимум 7. Увеличиваем его на 3. Операций: 4 + 3 = 7. Теперь nums[3] = 7.
nums[4] = 1 должен быть больше nums[3] = 7. Он должен стать как минимум 8.
            Увеличиваем его на 7. Операций: 7 + 7 = 14.
Выход: 14
 */