Объяснение подходов:
1. Подход с массивом и сортировкой (оптимальный)
Сложность: O(m log n + m log m) по времени, O(m) по памяти
Основные шаги:
Для каждой строки находим количество единиц с помощью двоичного поиска
Сохраняем пары (количество_единиц, индекс_строки) в массив
Сортируем массив сначала по количеству единиц, потом по индексу
Берем первые k элементов

Преимущества:
Простая реализация
Хорошая производительность для средних размеров данных

2. Подход с приоритетной очередью
Сложность: O(m log n + m log k) по времени, O(k) по памяти
Основные шаги:
Используем max-heap для хранения k самых слабых строк
Для каждой строки вычисляем количество единиц
Добавляем в очередь и поддерживаем размер k
Извлекаем результаты в обратном порядке

Преимущества:
Лучше по памяти (O(k) вместо O(m))
Эффективнее при больших m и маленьких k