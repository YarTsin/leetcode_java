package org.example.g1301_1400.s1379_find_a_corresponding_node_of_a_binary_tree_in_a_clone_of_that_tree;

// #Easy #Depth_First_Search #Breadth_First_Search
// #Tree #Binary_Tree #Recursion

import org.example.a_leetcode_classes.TreeNode;

/**
 * 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
 *
 * Условие: Даны два бинарных дерева: original (оригинальное) и cloned
 * (его точная копия), а также указатель на узел target в оригинальном дереве.
 *
 * Необходимо вернуть ссылку на тот же самый узел в клоне дерева.
 * Проще говоря: У нас есть два одинаковых дерева. Мы знаем, на какой
 * узел смотрят в первом дереве. Нужно "ткнуть пальцем" в такой же узел
 * во втором дереве.
 *
 * Важные детали:
 * - Точная копия: Дерево cloned является точной копией дерева original.
 * Это означает, что структура деревьев идентична, и значения всех узлов совпадают.
 * - Один и тот же узел: Узел в cloned дереве считается соответствующим узлу
 * в original дереве, если они находятся в одинаковой позиции относительно
 * корня дерева (т.е. путь от корня к целевому узлу абсолютно одинаков
 * в обоих деревьях).
 * - Ссылка на узел: Входной параметр target — это ссылка на узел в дереве
 * original. Результатом должна быть ссылка на узел в дереве cloned.
 * - Значения уникальны: В условии оговаривается, что значения всех узлов
 * в дереве уникальны. Это ключевой момент, который позволяет предложить
 * простое решение.
 * (пример внизу)
 *
 * Решение Одновременный обход - 2-е по скорости - 1 ms
 *
 * Временная сложность: O(n), где n — количество узлов в дереве.
 * В худшем случае мы посетим все узлы дерева (если target — это самый правый лист).
 * Пространственная сложность: O(h), где h — высота дерева.
 * Эта память используется для стека вызовов рекурсии.
 * В худшем случае (вырожденное дерево-цепочка) сложность будет O(n),
 * в сбалансированном — O(log n).
 *
 */
class Solution {
    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {
        // Базовый случай рекурсии: если оригинальное дерево пустое,
        // то и в клоне искать нечего, возвращаем null.
        if (original == null) {
            return null;
        }

        // Проверяем, не нашли ли мы целевой узел в ОРИГИНАЛЬНОМ дереве.
        // Сравниваем именно ссылки (original == target), а не значения.
        // Это ключевой момент, гарантирующий, что мы нашли нужный узел.
        if (original == target) {
            // Если мы нашли target в оригинальном дереве, то возвращаем
            // соответствующий узел из дерева-клона на этой же позиции обхода.
            return cloned;
        }

        // Рекурсивно ищем в левом поддереве.
        // Запускаем тот же алгоритм для левых детей оригинального и клонированного деревьев.
        TreeNode leftSearchResult = getTargetCopy(original.left, cloned.left, target);

        // Если поиск в левом поддереве дал результат (нашелся не-null узел),
        // значит, цель найдена, и можно сразу вернуть этот результат.
        if (leftSearchResult != null) {
            return leftSearchResult;
        }

        // Если в левом поддереве цель не найдена, рекурсивно ищем в правом поддереве.
        // Запускаем тот же алгоритм для правых детей оригинального и клонированного деревьев.
        TreeNode rightSearchResult = getTargetCopy(original.right, cloned.right, target);

        // Возвращаем результат поиска в правом поддереве (найденный узел или null).
        return rightSearchResult;
    }
}
/*
Пример 1
Ввод:
original: [7,4,3,null,null,6,19] (представление в виде массива)
cloned: [7,4,3,null,null,6,19] (такой же массив)
target: Узел со значением 3 (из оригинального дерева)

    original           cloned
        7                 7
       / \               / \
      4   3             4   3
         / \               / \
        6  19             6  19
Вывод: Ссылка на узел со значением 3 в дереве cloned.
 */