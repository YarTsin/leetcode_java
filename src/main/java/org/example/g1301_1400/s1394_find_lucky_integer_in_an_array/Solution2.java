package org.example.g1301_1400.s1394_find_lucky_integer_in_an_array;

/**
 * Альтернативный подход: Использование массива для подсчета частот
 * Если известны ограничения на значения элементов в массиве,
 * можно использовать массив вместо HashMap. В условии задачи
 * сказано: 1 <= arr[i] <= 500. Это позволяет создать массив
 * фиксированного размера.
 *
 * Временная сложность: O(n) для первого прохода + O(1) для второго прохода,
 * так как размер массива фиксирован (500 элементов). Общая сложность O(n).
 * Пространственная сложность: O(1), так как мы используем массив фиксированного
 * размера (501 элемент), который не зависит от размера входного массива n.
 */
class Solution2 {
    public int findLucky(int[] arr) {
        // По условию задачи, значения в массиве находятся в диапазоне [1, 500]
        // Создаем массив для подсчета частот размером 501 (индексы от 1 до 500)
        int[] frequency = new int[501]; // Индексы 0 не используется, так числа от 1 до 500

        // Первый проход по массиву: увеличиваем счетчик для каждого числа
        for (int num : arr) {
            // Так как num >= 1 и <= 500, мы можем безопасно использовать его как индекс
            frequency[num]++;
        }

        int largestLuckyNumber = -1;

        // Второй проход: идем по массиву частот С КОНЦА В НАЧАЛО.
        // Это позволяет сразу найти наибольшее счастливое число без полного прохода.
        // Мы начинаем с самого большого возможного числа (500) и идем вниз.
        for (int num = 500; num >= 1; num--) {
            // Проверяем условие счастливого числа
            if (frequency[num] == num) {
                // Как только находим первое подходящее число (а идем мы от большего к меньшему),
                // оно автоматически будет наибольшим возможным счастливым числом.
                return num;
            }
        }

        // Если ничего не нашли, возвращаем -1
        return -1;
    }
}
