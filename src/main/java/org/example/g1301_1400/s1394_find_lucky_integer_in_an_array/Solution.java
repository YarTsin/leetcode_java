package org.example.g1301_1400.s1394_find_lucky_integer_in_an_array;

// #Easy #Array #Hash_Table #Counting


import java.util.HashMap;
import java.util.Map;

/**
 * 1394. Find Lucky Integer in an Array
 *
 * Дан массив целых чисел arr. Счастливое число — это такое число x,
 * что частота его встречаемости в массиве ровно равна его значению.
 * Другими словами, если число x встречается в массиве x раз.
 *
 * Необходимо найти наибольшее счастливое число в массиве.
 * Если счастливых чисел несколько, вернуть самое большое из них.
 * Если счастливого числа нет, вернуть -1.
 *
 * Проще говоря: Нужно для каждого уникального числа в массиве посчитать,
 * сколько раз оно встречается. Затем проверить, совпадает ли это
 * количество с самим числом. Из всех таких чисел выбрать самое большое.
 * (примеры внизу)
 *
 * Решение - Использование HashMap для подсчета частот
 * Не быстрое решение - 6 ms
 *
 * Временная сложность: O(n), где n - длина массива. Мы делаем два
 * последовательных прохода по n элементам (первый — для заполнения
 * карты, второй — по уникальным элементам карты, которых в худшем случае тоже n).
 * Пространственная сложность: O(n) для хранения HashMap в худшем случае,
 * когда все элементы в массиве уникальны.
 */
class Solution {
    public int findLucky(int[] arr) {
        // Создаем HashMap для подсчета частот чисел
        // Ключ: число из массива
        // Значение: количество раз, которое это число встречается
        Map<Integer, Integer> frequencyMap = new HashMap<>();

        // Первый проход по массиву: заполняем карту частот
        for (int num : arr) {
            // Метод getOrDefault возвращает значение для ключа num, если оно есть,
            // или 0, если ключа нет. Затем мы увеличиваем это значение на 1 и кладем обратно.
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // Переменная для хранения наибольшего счастливого числа.
        // Инициализируем как -1, так как это значение нужно вернуть, если ничего не найдено.
        int largestLuckyNumber = -1;

        // Второй проход: итерируемся по всем уникальным числам (ключам) в карте
        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
            int number = entry.getKey();    // Само число
            int frequency = entry.getValue(); // Его частота

            // Проверяем условие счастливого числа: число должно равняться своей частоте
            if (number == frequency) {
                // Если условие выполняется, сравниваем текущее число с текущим максимумом
                // и обновляем максимум, если текущее число больше.
                if (number > largestLuckyNumber) {
                    largestLuckyNumber = number;
                }
            }
        }

        // Возвращаем наибольшее счастливое число или -1, если таковых не нашлось
        return largestLuckyNumber;
    }
}
/*
Пример 1
Ввод: arr = [2,2,3,4]
Объяснение:
Число 2 встречается 2 раза -> 2 == 2 -> счастливое.
Число 3 встречается 1 раз -> 1 != 3 -> не счастливое.
Число 4 встречается 1 раз -> 1 != 4 -> не счастливое.
Вывод: 2 (единственное счастливое число)


Пример 2
Ввод: arr = [1,2,2,3,3,3]
Объяснение:
Число 1 встречается 1 раз -> 1 == 1 -> счастливое.
Число 2 встречается 2 раза -> 2 == 2 -> счастливое.
Число 3 встречается 3 раза -> 3 == 3 -> счастливое.
Вывод: 3 (наибольшее из счастливых чисел)

 */
