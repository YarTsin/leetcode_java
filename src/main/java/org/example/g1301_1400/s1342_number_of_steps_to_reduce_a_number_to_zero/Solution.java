package org.example.g1301_1400.s1342_number_of_steps_to_reduce_a_number_to_zero;

// #Easy #Math #Bit_Manipulation #Интересно

/**
 * 1342. Number of Steps to Reduce a Number to Zero
 *
 * Дано неотрицательное целое число num.
 * Нужно посчитать количество шагов, чтобы уменьшить его до нуля.
 *
 * Правила на каждом шаге:
 * Если текущее число четное, нужно разделить его на 2
 * Если текущее число нечетное, нужно вычесть из него 1
 * Цель: Вернуть общее количество шагов для уменьшения числа до нуля.
 * (примеры внизу)
 *
 * Решение - побитовые операции - самое быстрое решение - 0 ms
 *
 * Подход: Побитовые операции
 * Каждый шаг вычитания 1 (для нечетного числа) соответствует
 * установке младшего бита в 0
 * Каждое деление на 2 соответствует сдвигу вправо на 1 бит
 * Можно считать биты: каждый установленный бит требует
 * шага вычитания, каждый бит кроме старшего требует шага деления
 *
 */
class Solution {
    public int numberOfSteps(int num) {
        if (num == 0) return 0;

        int steps = 0;

        while (num > 0) {
            // Для нечетного числа: вычитаем 1 (убираем младший бит)
            // Для четного числа: делим на 2 (сдвиг вправо)
            if ((num & 1) == 1) { // Нечетное число
                num--; // Эквивалентно: num &= ~1;
            } else { // Четное число
                num >>= 1; // Деление на 2
            }
            steps++;
        }

        return steps;
    }
}
/*
Пример 1
Вход: num = 14
Выход: 6
Объяснение:
Шаг 1: 14 четное → делим на 2 = 7
Шаг 2: 7 нечетное → вычитаем 1 = 6
Шаг 3: 6 четное → делим на 2 = 3
Шаг 4: 3 нечетное → вычитаем 1 = 2
Шаг 5: 2 четное → делим на 2 = 1
Шаг 6: 1 нечетное → вычитаем 1 = 0

Пример 2
Вход: num = 8
Выход: 4
Объяснение:
Шаг 1: 8 четное → делим на 2 = 4
Шаг 2: 4 четное → делим на 2 = 2
Шаг 3: 2 четное → делим на 2 = 1
Шаг 4: 1 нечетное → вычитаем 1 = 0

 */