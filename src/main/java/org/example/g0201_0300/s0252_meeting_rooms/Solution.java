package org.example.g0201_0300.s0252_meeting_rooms;

//#Easy #Array #Sort #Premium

import java.util.Arrays;
import java.util.Comparator;

/**
 * 252. Meeting Rooms
 *
 * Задача Может ли человек посетить все встречи,
 * которые представлены в виде массива интервалов.
 * Другими словами, нужно проверить, не перекрываются ли интервалы встреч.
 *
 * Сортировка - частое решение задач с интервалами
 * Примеры
 * Пример 1
 * Вход: intervals = [[0, 30], [5, 10], [15, 20]]
 * Встреча [0, 30] пересекается с [5, 10] (30 > 5), поэтому человек не сможет посетить все встречи.
 * Ожидаемый результат: false
 *
 * Пример 2
 * Вход: intervals = [[7, 10], [2, 4]]
 * Сначала сортируем интервалы по началу: [[2, 4], [7, 10]].
 * [2, 4] и [7, 10] не пересекаются (4 ≤ 7).
 * Ожидаемый результат: true
 *
 * Решение связано с сортировкой массивов
 * todo добавить readme.md на английском chat
 */
public class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        // Проверяем пустые входные данные или отсутствие встреч
        if (intervals == null || intervals.length == 0) {
            return true;
        }

        // Сортируем интервалы по времени начала встречи
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

        // Проверяем каждую следующую встречу на пересечение с предыдущей
        for (int i = 0; i < intervals.length - 1; i++) {
            // Если время окончания текущей встречи больше времени начала следующей,
            // значит есть пересечение - возвращаем false
            if (intervals[i][1] > intervals[i + 1][0]) {
                return false;
            }
        }

        // Если пересечений не найдено - возвращаем true
        return true;
    }
}
/*
Объяснение решения:
Сортировка интервалов: Сначала мы сортируем все интервалы
по времени начала встречи. Это позволяет нам проверять
пересечения последовательно.
Проверка пересечений: После сортировки достаточно проверить,
что время окончания текущей встречи не превышает время начала следующей встречи.
Сложность:
Сортировка занимает O(n log n) времени
Последующий проход по массиву - O(n)
Общая сложность: O(n log n)
 */