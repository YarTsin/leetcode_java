Оптимальное решение (Бинарный поиск)

Объяснение подхода:
Используем бинарный поиск для минимизации вызовов API
Если mid - плохая версия, первая плохая может быть mid или левее
Если mid - хорошая версия, первая плохая должна быть правее
Цикл продолжается пока left < right
Когда цикл завершается, left указывает на первую плохую версию
Временная сложность: O(log n)
Пространственная сложность: O(1)

Детальное объяснение работы бинарного поиска
Почему работает бинарный поиск:
Монотонность: Все версии после первой плохой также плохие
Двоичное свойство:
- Если версия mid плохая, то первая плохая версия ≤ mid
- Если версия mid хорошая, то первая плохая версия > mid


Важность предотвращения переполнения:
Используем left + (right - left) / 2 вместо (left + right) / 2
Это предотвращает переполнение при больших значениях n (до 2³¹)