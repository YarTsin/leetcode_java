# Подробное объяснение решения с XOR для задачи "Missing Number"

## Основная идея XOR

XOR (исключающее ИЛИ) — это битовая операция, которая работает следующим образом:
- `0 ^ 0 = 0`
- `0 ^ 1 = 1`
- `1 ^ 0 = 1`
- `1 ^ 1 = 0`

Ключевые свойства XOR, которые мы используем:
1. **Коммутативность**: `a ^ b = b ^ a`
2. **Ассоциативность**: `(a ^ b) ^ c = a ^ (b ^ c)`
3. **Свойство нуля**: `a ^ 0 = a`
4. **Свойство аннигиляции**: `a ^ a = 0`

## Как это помогает найти пропущенное число?

Алгоритм:
1. Начинаем с `missing = n` (так как числа от 0 до n)
2. Для каждого индекса `i` от 0 до n-1:
   - XOR `missing` с `i` (текущий индекс)
   - XOR `missing` с `nums[i]` (число в массиве)
3. В результате получим пропущенное число

## Почему это работает?

Рассмотрим пример `nums = [3,0,1]`, n = 3:

Шаги выполнения:
1. `missing = 3` (начальное значение)
2. i = 0:
   - `missing ^= 0 ^ 3` → 3 ^ 0 ^ 3 = (3 ^ 3) ^ 0 = 0 ^ 0 = 0
3. i = 1:
   - `missing ^= 1 ^ 0` → 0 ^ 1 ^ 0 = (0 ^ 0) ^ 1 = 0 ^ 1 = 1
4. i = 2:
   - `missing ^= 2 ^ 1` → 1 ^ 2 ^ 1 = (1 ^ 1) ^ 2 = 0 ^ 2 = 2

Результат: 2 (правильный ответ)

## Визуализация процесса

Для массива `[3,0,1]` (n=3):

```
Все числа, которые должны быть: 0, 1, 2, 3
Фактические числа: 3, 0, 1

Выполняем:
(0 ^ 1 ^ 2 ^ 3) ^ (3 ^ 0 ^ 1) =
(0 ^ 0) ^ (1 ^ 1) ^ (2) ^ (3 ^ 3) =
0 ^ 0 ^ 2 ^ 0 = 2
```

## Почему начинаем с `missing = n`?

Потому что:
- Диапазон чисел от 0 до n
- В массиве n элементов (не хватает одного)
- Нам нужно включить n в вычисления

## Преимущества этого метода

1. **Нет проблемы переполнения**: В отличие от метода суммы, не зависит от величины чисел
2. **Эффективность**: Один проход по массиву (O(n) времени)
3. **Константная память**: O(1) дополнительной памяти

## Полный код с комментариями

```java
class Solution {
    public int missingNumber(int[] nums) {
        int missing = nums.length; // Начинаем с n (так как числа от 0 до n)

        for (int i = 0; i < nums.length; i++) {
            // XOR с индексом (ожидаемое число) и значением (фактическое число)
            missing ^= i ^ nums[i];

            // Пошагово это эквивалентно:
            // missing = missing ^ i ^ nums[i];
        }

        return missing;
    }
}
```

## Как думать о таком решении?

1. Представьте, что у вас есть все числа от 0 до n
2. И есть все числа из массива + пропущенное
3. Если сделать XOR всех чисел из обоих наборов, все парные числа уничтожатся (так как x ^ x = 0)
4. Останется только пропущенное число (так как у него нет пары)

Это элегантное решение демонстрирует мощь битовых операций для определенного класса задач!