Сравнение решений
DFS с backtracking (оптимальное):
Временная сложность: O(N) - посещаем каждый узел один раз
Пространственная сложность: O(H) для стека вызовов, где H - высота дерева
Эффективно использует память благодаря backtracking

DFS с созданием новых строк:
Временная сложность: O(N)
Пространственная сложность: O(N²) из-за создания новых строк на каждом шаге
Проще для понимания, но менее эффективно по памяти

BFS с очередью:
Временная сложность: O(N)
Пространственная сложность: O(N) для хранения узлов и путей в очередях
Подходит для широких деревьев, но использует больше памяти

=============

Как это работает на примере
Дерево
    1
   / \
  2   3

Шаг за шагом:
Начинаем с корня (1)
currentPath = "" → становится "1"
Есть дети (2 и 3), идем сначала влево
Переходим к узлу 2
currentPath = "1" → становится "1->2"
Узел 2 - лист! Добавляем "1->2" в результат
Backtracking: возвращаемся к "1"
Переходим к узлу 3
currentPath = "1" → становится "1->3"
Узел 3 - лист! Добавляем "1->3" в результат
Backtracking: возвращаемся к "1"
Возвращаемся из корня
Backtracking: возвращаемся к пустой строке
