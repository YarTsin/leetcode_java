package org.example.g0601_0700.s0657_robot_return_to_origin;

// #Easy #String #Simulation

/**
 * 657. Robot Return to Origin
 *
 * Есть робот, который начинает движение из точки начала
 * координат (0, 0). Дана строка moves, которая представляет
 * последовательность движений робота.
 * Строка состоит только из символов:
 * 'R' (right) - движение вправо
 * 'L' (left) - движение влево
 * 'U' (up) - движение вверх
 * 'D' (down) - движение вниз
 * Необходимо определить, возвращается ли робот в исходную точку
 * (0, 0) после выполнения всех движений.
 * (примеры внизу)
 *
 * Решение: подсчет перемещений - 4-е решение - 4 ms
 *
 * Сложность:
 * Временная: O(n) - где n длина строки moves
 * Пространственная: O(1) - используем только константную память
 *
 *
 */
class Solution {
    public boolean judgeCircle(String moves) {
        int x = 0; // Горизонтальная координата
        int y = 0; // Вертикальная координата

        // Обрабатываем каждое движение
        for (char move : moves.toCharArray()) {
            switch (move) {
                case 'R': x++; break; // Вправо: увеличиваем x
                case 'L': x--; break; // Влево: уменьшаем x
                case 'U': y++; break; // Вверх: увеличиваем y
                case 'D': y--; break; // Вниз: уменьшаем y
            }
        }

        // Возвращаемся в начало, если обе координаты равны 0
        return x == 0 && y == 0;
    }
}
/*
Пример 1

Вход: moves = "UD"
Выход: true
Объяснение:
- "U" → (0, +1)
- "D" → (0, -1)
Итог: (0, 0) ✓

Пример 2
Вход: moves = "LL"
Выход: false
Объяснение:
- "L" → (-1, 0)
- "L" → (-2, 0)
Итог: (-2, 0) ✗

Пример 3
Вход: moves = "RRDD"
Выход: false
 */
