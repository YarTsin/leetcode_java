package org.example.g0601_0700.s0645_set_mismatch;

/**
 * #Easy #Array #Math
 *
 * Вам дан массив nums, представляющий набор чисел от 1 до n, где:
 * Одно число продублировано (дубликат)  * Одно число отсутствует (пропуск)
 * Необходимо найти и вернуть дубликат и пропущенное число в
 * виде массива [дубликат, пропуск].
 * Пример 1  * Вход: [1,2,2,4]  * Выход: [2,3]
 * Объяснение:
 * - Дубликат: 2 (встречается дважды)
 * - Пропуск: 3 (отсутствует в массиве)
 *
 * Пример 2  * Вход: [1,1]  * Выход: [1,2]
 * Объяснение:
 * - Дубликат: 1 (встречается дважды)
 * - Пропуск: 2 (отсутствует в массиве)
 *
 * Пример 3  * Вход: [2,2]  * Выход: [2,1]
 * Объяснение:
 * - Дубликат: 2 (встречается дважды)
 * - Пропуск: 1 (отсутствует в массиве)
 *
 * Можно ли сказать что массив отсортирован по возрастанию?
 *
 * Оптимальное решение с использованием математики (2 ms)
 */
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int sum = n * (n + 1) / 2;  // Ожидаемая сумма 1..n
        int actualSum = 0;
        int duplicate = -1;

        // Используем массив для отметки встреченных чисел
        boolean[] seen = new boolean[n + 1];

        for (int num : nums) {
            actualSum += num;
            if (seen[num]) {
                duplicate = num;  // Нашли дубликат
            }
            seen[num] = true;
        }

        // Пропуск = ожидаемая сумма - (фактическая сумма - дубликат)
        int missing = sum - (actualSum - duplicate);

        return new int[]{duplicate, missing};
    }
}
/*
Объяснение решения:
Вычисление сумм:
Рассчитываем ожидаемую сумму чисел от 1 до n по формуле n*(n+1)/2
Считаем фактическую сумму элементов массива
Поиск дубликата:
Используем массив seen для отслеживания уже встреченных чисел
Если число уже встречалось - это наш дубликат

Вычисление пропуска:
Пропущенное число = ожидаемая сумма - (фактическая сумма - дубликат)

Временная сложность: O(n)
Пространственная сложность: O(n) (для массива seen)
 */
