package org.example.g0601_0700.s0605_can_place_flowers;

// #Easy #Array #Greedy #LeetCode_75_Array/String

/**
 * 605. Can Place Flowers
 *
 * Условие: У вас есть длинная клумба, в которой некоторые
 * участки заняты, а некоторые нет. Однако цветы нельзя сажать
 * на соседних участках — если посадить цветы рядом, они конкурируют
 * за воду и оба погибают.
 *
 * Дано:
 * Массив flowerbed из целых чисел, где:
 * 0 означает пустой участок
 * 1 означает занятый участок
 *
 * Целое число n - количество новых цветов, которые нужно посадить
 *
 * Задача: Определить, можно ли посадить n новых цветов на клумбу,
 * не нарушая правило отсутствия соседних цветов.
 *
 * Пример 1
 * Input: flowerbed = [1,0,0,0,1], n = 1
 * Output: true
 * Объяснение: Можно посадить цветок на второй или третьей позиции
 *
 * Пример 2
 * Input: flowerbed = [1,0,0,0,1], n = 2
 * Output: false
 * Объяснение: Нельзя посадить два цветка без нарушения правила соседства
 *
 * Оптимальное решение: жадный алгоритм - 1 ms
 *
 */
public class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int count = 0;
        int length = flowerbed.length;

        for (int i = 0; i < length; i++) {
            // Проверяем, можно ли посадить цветок на текущей позиции
            if (flowerbed[i] == 0) {
                // Проверяем левого соседа (если он существует)
                boolean leftEmpty = (i == 0) || (flowerbed[i - 1] == 0);
                // Проверяем правого соседа (если он существует)
                boolean rightEmpty = (i == length - 1) || (flowerbed[i + 1] == 0);

                // Если оба соседа пусты или не существуют, сажаем цветок
                if (leftEmpty && rightEmpty) {
                    flowerbed[i] = 1; // Помечаем позицию как занятую
                    count++; // Увеличиваем счетчик посаженных цветов

                    // Если посадили достаточно цветов, возвращаем true
                    if (count >= n) {
                        return true;
                    }
                }
            }
        }

        // Проверяем, удалось ли посадить достаточно цветов
        return count >= n;
    }
}

/*
Оптимальное решение
Подход: Жадный алгоритм. Проходим по массиву и сажаем цветы везде,
где это возможно, соблюдая правила. Подсчитываем,
сколько цветов можем посадить.

Сложность: O(n) - один проход по массиву
Память: O(1) - константная дополнительная память
 */