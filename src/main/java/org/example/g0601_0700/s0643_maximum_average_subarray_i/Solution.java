package org.example.g0601_0700.s0643_maximum_average_subarray_i;

// #Easy #Array #Sliding_Window #LeetCode_75_Sliding_Window
// #Prefix

/**
 * 643. Maximum Average Subarray I
 * Дан целочисленный массив nums и целое число k.
 * Необходимо найти непрерывный подмассив длины k, который имеет
 * максимальное среднее значение, и вернуть это максимальное
 * среднее значение.
 *
 * todo что такое максимальное среднее в подмассиве
 * Условия:
 * Длина массива: 1 ≤ n ≤ 10^5
 * Элементы массива: -10^4 ≤ nums[i] ≤ 10^4
 * 1 ≤ k ≤ n
 *
 * Пример 1
 * Вход: nums = [1,12,-5,-6,50,3], k = 4
 * Выход: 12.75000
 *
 * Объяснение:
 * Максимальное среднее находится в подмассиве [12,-5,-6,50] = (12 - 5 - 6 + 50)/4 = 51/4 = 12.75
 *
 * Решение: скользящее окно - самое быстрое 2 ms
 *
 *
 * Сложность:
 * Временная: O(n) - проходим по массиву два раза: один раз для первого окна, второй для остальных
 * Пространственная: O(1) - используем только константное количество дополнительной памяти
 */
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        // Вычисляем сумму первого окна длины k
        int windowSum = 0;
        for (int i = 0; i < k; i++) {
            windowSum += nums[i];
        }

        // Инициализируем максимальную сумму суммой первого окна
        int maxSum = windowSum;

        // Сдвигаем окно и обновляем максимальную сумму
        for (int i = k; i < nums.length; i++) {
            // Добавляем новый элемент и убираем первый элемент предыдущего окна
            windowSum = windowSum + nums[i] - nums[i - k];

            // Обновляем максимальную сумму, если текущая сумма больше
            if (windowSum > maxSum) {
                maxSum = windowSum;
            }
        }

        // Возвращаем максимальное среднее значение
        return (double) maxSum / k;
    }
}
