package org.example.g1501_1600.s1560_most_visited_sector_in_a_circular_track;

// #Easy #Array #Simulation #Circle

import java.util.ArrayList;
import java.util.List;

/**
 * 1560. Most Visited Sector in a Circular Track
 *
 * Есть круговая дорожка, состоящая из n секторов, пронумерованных
 * от 1 до n по часовой стрелке. Начинаем движение из сектора 1.
 *
 * Дан массив rounds, где rounds[i] представляет собой сектор,
 * где бегун находится в конце i-го раунда.
 * Необходимо найти наиболее часто посещаемые сектора на круговой
 * дорожке. Сектор считается посещенным, если бегун проходит
 * через него (включая начальную и конечную точки).
 *
 * Важные моменты:
 * Бегун движется по кругу по часовой стрелке
 * Нужно учитывать все пройденные сектора между раундами
 * Возвращаем список наиболее посещаемых секторов в возрастающем порядке
 * (примеры внизу)
 *
 * Решение - математический подход - самое быстрое - 0 ms
 *
 */
class Solution {
    public List<Integer> mostVisited(int n, int[] rounds) {
        List<Integer> result = new ArrayList<>();
        int start = rounds[0];
        int end = rounds[rounds.length - 1];

        if (start <= end) {
            // Если начальный сектор <= конечному, просто добавляем все сектора от start до end
            for (int i = start; i <= end; i++) {
                result.add(i);
            }
        } else {
            // Если начальный сектор > конечного, добавляем сектора от 1 до end и от start до n
            for (int i = 1; i <= end; i++) {
                result.add(i);
            }
            for (int i = start; i <= n; i++) {
                result.add(i);
            }
        }

        return result;
    }
}
/*
Пример 1
Вход: n = 4, rounds = [1,3,1,2]
Выход: [1,2]
Объяснение:
Раунд 1: 1→2→3 (посещены 1,2,3)
Раунд 2: 3→4→1 (посещены 3,4,1)
Раунд 3: 1→2 (посещены 1,2)
Счетчик: 1:3, 2:2, 3:2, 4:1
Наиболее посещаемые: 1 и 2

Пример 2
Вход: n = 2, rounds = [2,1,2,1,2,1,2,1,2]
Выход: [2]

Пример 3
Вход: n = 7, rounds = [1,3,5,7]
Выход: [1,2,3,4,5,6,7]
*/
