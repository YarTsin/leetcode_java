Объяснение подходов:
1. Бинарный поиск (оптимальный)
Сложность: O(log n) по времени, O(1) по памяти
Основные шаги:
Используем бинарный поиск для нахождения позиции
Вычисляем количество пропущенных чисел до текущего элемента: arr[mid] - (mid + 1)
Если пропущенных чисел меньше k - ищем справа
Если пропущенных чисел больше или равно k - ищем слева
После цикла используем формулу left + k
Преимущества:
Логарифмическая сложность
Эффективно для больших массивов

2. Линейный поиск
Сложность: O(n + k) по времени, O(1) по памяти
Основные шаги:
Имитируем последовательность натуральных чисел
Сравниваем с элементами массива
Считаем пропущенные числа
Недостатки:
Медленно при больших k
Не использует преимущества сортировки

3. Решение с множеством
Сложность: O(n) по времени, O(n) по памяти
Основные шаги:
Помещаем все числа массива в HashSet
Последовательно проверяем натуральные числа
Считаем пропущенные
Недостатки:
Дополнительная память O(n)
Медленно при больших k