Подходы к решению
1. Использование HashSet (оптимальное решение)
Преобразуем первый массив в множество (HashSet) для быстрого поиска и устранения дубликатов
Проходим по второму массиву и проверяем наличие элементов в множестве
Добавляем совпадающие элементы в результат
Преобразуем результат в массив

2. Сортировка + два указателя
Сортируем оба массива
Используем два указателя для поиска общих элементов
Пропускаем дубликаты при добавлении в результат

===================

Объяснение для новичка
HashSet для первого массива:
Преобразуем nums1 в множество set1, что автоматически удаляет дубликаты
Поиск в HashSet работает за O(1) в среднем случае

Поиск пересечения:
Для каждого элемента nums2 проверяем его наличие в set1
Если элемент найден, добавляем его в resultSet (это снова HashSet для избежания дубликатов)

Преобразование результата:
Создаем массив нужного размера (равного размеру resultSet)
Копируем элементы из множества в массив

=====================

Временная сложность
O(n + m), где n и m - длины массивов:
O(n) для создания первого множества
O(m) для проверки элементов второго массива
O(k) для преобразования результата в массив (k ≤ min(n, m))

Пространственная сложность
O(n + k), где:
O(n) для хранения первого множества
O(k) для хранения результата (k - количество общих элементов)