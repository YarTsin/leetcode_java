Объяснение для новичка
Инициализация массива:

Создаем массив ans длиной n + 1 (так как включаем 0)
ans[0] автоматически инициализируется как 0

Заполнение массива:
Для каждого числа i от 1 до n:
i >> 1 эквивалентно делению i на 2 (отбрасываем младший бит)
i & 1 дает младший бит числа i (0 или 1)

Таким образом, ans[i] = ans[i/2] + (0 или 1)

Пример работы:
i=1: ans[1] = ans[0] + 1 = 0 + 1 = 1
i=2: ans[2] = ans[1] + 0 = 1 + 0 = 1
i=3: ans[3] = ans[1] + 1 = 1 + 1 = 2

====================

Временная сложность
O(n) - мы делаем один проход от 1 до n, и каждая операция выполняется за O(1).

Пространственная сложность
O(n) - для хранения результата (массива длиной n+1).


====================
Альтернативное решение (DP + последний установленный бит)

public class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];

        for (int i = 1; i <= n; i++) {
            // i & (i - 1) удаляет последний установленный бит
            ans[i] = ans[i & (i - 1)] + 1;
        }

        return ans;
    }
}

Это решение работает на том принципе, что i & (i - 1) удаляет последний
установленный бит в i, поэтому количество единиц в i на 1 больше, чем в этом числе.

===================

Дополнительные вопросы для собеседования
1. Как изменится решение, если нужно считать не единицы, а нули?
Нужно учитывать ведущие нули или нет? Если нет, то bitLength - countOnes

2. Как решить задачу без использования операций с битами?
Можно использовать деление на 2 и проверку остатка: ans[i] = ans[i/2] + i%2

3. Как найти число с максимальным количеством единиц в диапазоне от 0 до n?
Пройти по массиву ans и найти максимальное значение

4. Как изменить решение для чисел в других системах счисления?
Аналогичный подход можно использовать, заменив операции
на соответствующие для другой системы

=====================

Математическое примечание
Эта задача демонстрирует красивое свойство двоичных чисел:
Количество единиц в числе i равно количеству единиц в i/2 плюс младший бит i
Это позволяет эффективно использовать уже вычисленные результаты

=====================

Подробное объяснение битов и формулы подсчета единиц

Что такое младший и старший бит?
Представьте, что число - это последовательность лампочек (битов), где каждая может быть либо включена (1), либо выключена (0).

Например, число 5 в двоичной системе:
1 0 1

Младший бит (LSB - Least Significant Bit) - это самый ПРАВЫЙ бит (последняя цифра в записи)
Старший бит (MSB - Most Significant Bit) - это самый ЛЕВЫЙ бит (первая цифра в записи)

========================

Формула: "Количество единиц в i = количеству единиц в i/2 + младший бит i"
Разберем это на примерах:

Пример 1: i = 5 (101)
i/2 = 2 (10) - отбрасываем младший бит
Количество единиц в 2 (10) = 1
Младший бит 5 (101) = 1
Итого: 1 (от i/2) + 1 (младший бит) = 2 единицы в 101

======================

Визуализация для чисел от 0 до 8:
Число	Двоичное	i/2	Младший бит	Формула	Единиц
0	0	-	0	-	0
1	1	0	1	0 + 1	1
2	10	1	0	1 + 0	1
3	11	1	1	1 + 1	2
4	100	2	0	1 + 0	1
5	101	2	1	1 + 1	2
6	110	3	0	2 + 0	2
7	111	3	1	2 + 1	3
8	10004	0	1 + 0	1

========================
Как это применяется в коде?
В решении задачи:

ans[i] = ans[i >> 1] + (i & 1);
i >> 1 - это сдвиг вправо (деление на 2)
i & 1 - проверка младшего бита (1 если нечетное, 0 если четное)

Таким образом, мы используем уже вычисленные результаты
для меньших чисел, что делает алгоритм очень эффективным



