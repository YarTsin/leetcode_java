Сравнение подходов
Итеративный подход:
Прост для понимания
Временная сложность: O(log₃n)
Пространственная сложность: O(1)

Логарифмический подход:
Теоретически O(1), но проблемы с точностью
Может давать ложные срабатывания из-за ошибок округления

Максимальная степень:
Наиболее эффективное (O(1))
Использует математическое свойство
Работает только для чисел в пределах int

======

Объяснение метода с максимальной степенью тройки
Ключевая идея:
Метод основан на важном математическом свойстве степеней простых чисел:
Все степени числа 3 (и только они) являются делителями максимальной
степени тройки, которая помещается в 32-битное целое число.

Разберем по частям:
Максимальная степень тройки в int:
В 32-битном целом числе (int) максимальная степень тройки - это 3¹⁹ = 1162261467
Следующая степень (3²⁰ = 3486784401) уже превышает Integer.MAX_VALUE (2147483647)

Математическое обоснование:
Любая степень тройки 3ᵏ (где k ≤ 19) является делителем 3¹⁹

Например:
3² = 9, и 1162261467 ÷ 9 = 129140163 (целое)
3⁵ = 243, и 1162261467 ÷ 243 = 4782969 (целое)

Обратное также верно: если число является делителем 3¹⁹,
то оно само должно быть степенью тройки

Почему это работает:
Когда мы делаем 1162261467 % n == 0, мы проверяем, является ли n делителем 3¹⁹
Если да, то n обязательно должно быть степенью тройки (по свойству простых чисел)

Примеры:
Для n = 27 (3³):
1162261467 % 27 = 0 → true

Для n = 45:
1162261467 % 45 = 27 ≠ 0 → false

Для n = 1 (3⁰):
1162261467 % 1 = 0 → true

