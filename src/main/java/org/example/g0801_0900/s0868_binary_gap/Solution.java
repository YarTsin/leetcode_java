package org.example.g0801_0900.s0868_binary_gap;

// #Easy #Bit_Manipulation

/**
 * 868. Binary Gap
 *
 * Для положительного целого числа n найдите самый длинный промежуток между двумя
 * последовательными единицами в его двоичном представлении.
 * Если таких промежутков нет, верните 0.
 *
 * Определение бинарного промежутка: Расстояние между двумя последовательными
 * единицами в двоичном представлении числа. Например, в двоичном представлении
 * числа 22 (10110) есть два промежутка: длиной 1 и длиной 2.
 * (примеры внизу)
 *
 * Решение: Побитовая обработка с отслеживанием позиций единиц
 * Самое быстрое - 0 ms
 *
 * Сложность: O(log n) по времени, O(1) по дополнительной памяти
 */
class Solution {
    public int binaryGap(int n) {
        int maxGap = 0;
        int lastOnePosition = -1; // Позиция последней встреченной единицы
        int currentPosition = 0;

        while (n > 0) {
            // Проверяем младший бит
            if ((n & 1) == 1) {
                if (lastOnePosition != -1) {
                    // Вычисляем расстояние между текущей и предыдущей единицей
                    int currentGap = currentPosition - lastOnePosition;
                    maxGap = Math.max(maxGap, currentGap);
                }
                lastOnePosition = currentPosition;
            }

            // Сдвигаем число вправо и увеличиваем позицию
            n >>= 1;
            currentPosition++;
        }

        return maxGap;
    }
}
/*
Пример 1
Вход: n = 22
Двоичное представление: 10110
Промежутки: между первой и второй единицей - 2 позиции,
между второй и третьей - 1 позиция
Выход: 2

Пример 2
Вход: n = 8
Двоичное представление: 1000
Промежутков между единицами нет (только одна единица)
Выход: 0

Пример 3
Вход: n = 5
Двоичное представление: 101
Промежуток: между первой и второй единицей - 1 позиция
Выход: 1
 */