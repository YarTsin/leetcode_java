package org.example.g0801_0900.s0821_shortest_distance_to_a_character;

// #Easy #Array #String #Two_Pointers #Char

/**
 * 821. Shortest Distance to a Character
 *
 * Дана строка s и символ c. Символ c гарантированно
 * встречается в строке s хотя бы один раз.
 *
 * Верните массив answer той же длины, что и s, где
 * для каждого индекса i:
 * answer[i] - кратчайшее расстояние от позиции i
 * до ближайшего вхождения символа c в s
 * Расстояние между двумя индексами i и j вычисляется как |i - j|.
 *
 * Пример 1
 * Вход: s = "loveleetcode", c = "e"
 * Выход: [3,2,1,0,1,0,0,1,2,2,1,0]
 * Объяснение:
 * Символ 'e' встречается на позициях: 3, 5, 6, 11
 * Для позиции 0: ближайший 'e' на позиции 3 → |0-3| = 3
 * Для позиции 1: ближайший 'e' на позиции 3 → |1-3| = 2
 * Для позиции 2: ближайший 'e' на позиции 3 → |2-3| = 1
 * Для позиции 3: 'e' на самой позиции → 0
 * И так далее...
 *
 * Пример 2
 * Вход: s = "aaab", c = "b"
 * Выход: [3,2,1,0]
 *
 * Решение - Двухпроходный алгоритм - 2e по скорости - 2 ms
 * Преимущества:
 * Временная сложность: O(n)
 * Пространственная сложность: O(n)
 * Элегантное решение без необходимости хранить все позиции c
 */
class Solution {
    public int[] shortestToChar(String s, char c) {
        int n = s.length();
        int[] answer = new int[n];

        // Первый проход: слева направо
        // Инициализируем большим значением (больше максимально возможного расстояния)
        int prev = -10000; // Минимальное значение, так как n <= 10000

        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == c) {
                prev = i; // Обновляем последнюю встреченную позицию c
            }
            answer[i] = i - prev; // Расстояние до последнего c слева
        }

        // Второй проход: справа налево
        prev = 10000; // Большое значение
        for (int i = n - 1; i >= 0; i--) {
            if (s.charAt(i) == c) {
                prev = i; // Обновляем последнюю встреченную позицию c справа
            }
            // Берем минимум из расстояния слева и расстояния справа
            answer[i] = Math.min(answer[i], prev - i);
        }

        return answer;
    }
}
