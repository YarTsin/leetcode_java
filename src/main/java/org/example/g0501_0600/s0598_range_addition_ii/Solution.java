package org.example.g0501_0600.s0598_range_addition_ii;

// #Easy #Array #Math #Matrix

/**
 * 598. Range Addition II
 * Вам дано целое число m (количество строк) и целое число
 * n (количество столбцов), которые представляют матрицу размером
 * m x n изначально заполненную нулями.
 *
 * Вам также дан массив операций ops, где каждая операция
 * ops[i] = [ai, bi] означает, что нужно инкрементировать
 * все элементы в подматрице от [0,0] до [ai-1, bi-1] на 1.
 *
 * todo запутанное условие
 *
 * После выполнения всех операций, нужно найти количество
 * максимальных целых чисел в матрице.
 * (примеры внизу)
 *
 * Решение: поиск минимальных значений - самое быстрое решение - 0 ms
 *
 * Объяснение подхода:
 * Каждая операция [ai, bi] инкрементирует подматрицу от [0,0] до [ai-1, bi-1]
 * Элементы, которые инкрементировались при ВСЕХ операциях, будут
 * иметь максимальное значение
 * Эти элементы образуют прямоугольник с размерами минимального
 * ai и минимального bi из всех операций
 *
 * Сложность:
 * Время: O(k), где k - количество операций
 * Память: O(1)
 *
 *
 *
 *
 */
class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        // Если операций нет, вся матрица остается нулевой
        // Максимальное значение 0 встречается m*n раз
        if (ops == null || ops.length == 0) {
            return m * n;
        }

        // Находим минимальные значения ai и bi среди всех операций
        int minA = Integer.MAX_VALUE;
        int minB = Integer.MAX_VALUE;

        for (int[] op : ops) {
            minA = Math.min(minA, op[0]);
            minB = Math.min(minB, op[1]);
        }

        // Область, которая инкрементировалась при ВСЕХ операциях
        // это прямоугольник от [0,0] до [minA-1, minB-1]
        return minA * minB;
    }
}
/*
Пример 1
Input: m = 3, n = 3, ops = [[2,2],[3,3]]
Output: 4

Изначально матрица
[0,0,0]
[0,0,0]
[0,0,0]

После операции [2,2]:
[1,1,0]
[1,1,0]
[0,0,0]

После операции [3,3]:
[2,2,1]
[2,2,1]
[1,1,1]

Максимальное значение - 2, и оно встречается 4 раза.

Пример 2
Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
Output: 4

Пример 3
Input: m = 3, n = 3, ops = []
Output: 9

 */