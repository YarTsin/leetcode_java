package org.example.g0501_0600.s0507_perfect_number;

// #Easy #Math

/**
 * 507. Perfect Number
 * Определите, является ли заданное положительное целое число num совершенным числом.
 *
 * Совершенное число - это положительное целое число, равное сумме своих положительных
 * делителей, исключая само число. Если это условие выполняется, верните true,
 * иначе верните false.
 *
 * Пример 1
 * Вход: num = 28
 * Выход: true
 * Объяснение:
 * Делители 28: 1, 2, 4, 7, 14 (исключая само число 28)
 * Сумма делителей: 1 + 2 + 4 + 7 + 14 = 28
 * Поскольку сумма равна исходному числу, возвращаем true.
 *
 * Пример 2
 * Вход: num = 7
 * Выход: false
 * Объяснение:
 * Делители 7: 1 (исключая 7)
 * Сумма делителей: 1 ≠ 7, поэтому возвращаем false.
 *
 * Ограничения:
 * 1 <= num <= 10^8
 *
 * Решение - перебор делителей - это самое быстрое решение 1 ms
 *
 * Сложность:
 * Время: O(√n), так как мы перебираем только до корня из num.
 * Память: O(1).
 */
class Solution {
    public boolean checkPerfectNumber(int num) {
        // Совершенное число должно быть больше 1
        if (num <= 1) {
            return false;
        }

        int sumOfDivisors = 1; // 1 является делителем для всех чисел > 1
        int sqrt = (int) Math.sqrt(num);

        // Перебираем возможные делители от 2 до корня из num
        for (int i = 2; i <= sqrt; i++) {
            if (num % i == 0) {
                sumOfDivisors += i;
                int counterpart = num / i;
                // Если делитель и его пара не одинаковы (например, для 28: 2 и 14)
                if (counterpart != i) {
                    sumOfDivisors += counterpart;
                }
            }
        }

        return sumOfDivisors == num;
    }
}
/*
Подход:
Вместо перебора всех чисел от 1 до num, мы можем перебирать только
до квадратного корня из num. Для каждого делителя i, если num делится на i,
то мы добавляем как i, так и num/i (если они не равны самому числу).
Однако нужно быть аккуратным с случаем, когда i и num/i одинаковы
(когда num является квадратом).

Алгоритм:
Если num == 1, возвращаем false (поскольку у 1 нет делителей кроме себя).
Инициализируем сумму делителей sumOfDivisors = 1 (поскольку 1 всегда делитель).
Перебираем i от 2 до sqrt(num).
Если num % i == 0, то добавляем i и num/i к сумме.
Если i == num/i, то добавляем только один раз (во избежание дублирования для квадратов).
Проверяем, равна ли сумма делителей num.
 */
