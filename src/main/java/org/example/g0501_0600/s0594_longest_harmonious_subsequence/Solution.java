package org.example.g0501_0600.s0594_longest_harmonious_subsequence;

// #Easy #Array #Hash_Table #Sorting

import java.util.HashMap;
import java.util.Map;

/**
 * 594. Longest Harmonious Subsequence
 *
 * Определим гармоничную подпоследовательность как подпоследовательность
 * массива, в которой разница между максимальным и минимальным
 * элементами равна ровно 1.
 * Необходимо найти длину самой длинной гармоничной подпоследовательности
 * в заданном массиве целых чисел.
 *
 * Особенности:
 * Подпоследовательность не обязательно должна быть непрерывной
 * Разница между максимальным и минимальным элементами должна быть ровно 1
 * Массив может содержать повторяющиеся элементы
 *
 * Пример1
 * Вход: nums = [1,3,2,2,5,2,3,7]
 * Выход: 5
 * Объяснение:
 * Самая длинная гармоничная подпоследовательность: [3,2,2,2,3].
 * Разница между максимальным (3) и минимальным (2) элементами равна 1.
 *
 * Пример2
 * Вход: nums = [1,2,3,4]
 * Выход: 2
 * Объяснение:
 * Возможные гармоничные подпоследовательности: [1,2], [2,3], [3,4].
 *
 * Пример3
 * Вход: nums = [1,1,1,1]
 * Выход: 0
 * Объяснение:
 * Нет гармоничной подпоследовательности, так как все элементы одинаковы.
 *
 * Отимальное решение - хеш карты
 *
 * Не самое быстрое решение - 16 ms
 * todo запутанное условие
 */
class Solution {
    public int findLHS(int[] nums) {
        // Создаем карту для подсчета частот чисел
        Map<Integer, Integer> frequencyMap = new HashMap<>();

        // Заполняем карту частотами
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        int maxLength = 0;

        // Проверяем все числа в карте
        for (int num : frequencyMap.keySet()) {
            // Если существует число на 1 больше текущего
            if (frequencyMap.containsKey(num + 1)) {
                // Сумма частот текущего числа и числа на 1 больше
                int currentLength = frequencyMap.get(num) + frequencyMap.get(num + 1);
                maxLength = Math.max(maxLength, currentLength);
            }
        }

        return maxLength;
    }
}
/*
Оптимальное решение (использование хэш-карты)
Подсчитываем частоту каждого числа в массиве
Для каждого числа проверяем наличие числа на 1 больше
Суммируем частоты текущего числа и числа на 1 больше
Находим максимальную такую сумму
Временная сложность: O(n)
Пространственная сложность: O(n)
 */
