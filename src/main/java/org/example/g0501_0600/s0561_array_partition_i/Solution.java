package org.example.g0501_0600.s0561_array_partition_i;

import java.util.Arrays;

/**
 * #Easy #Array #Sort #Greedy #Counting_Sort
 *
 * Дан массив nums из 2n целых чисел. Необходимо разбить эти числа
 * на n пар (a1, b1), (a2, b2), ..., (an, bn) так,
 * чтобы сумма min(a1, b1) + min(a2, b2) + ... + min(an, bn)
 * была максимально возможной. Верните эту максимальную сумму.
 *
 * Пример 1
 * Вход: nums = [1,4,3,2]
 * Выход: 4
 * Объяснение:
 * Все возможные разбиения (с соответствующими суммами минимумов):
 * 1. (1, 4), (3, 2) → min(1, 4) + min(3, 2) = 1 + 2 = 3
 * 2. (1, 3), (4, 2) → min(1, 3) + min(4, 2) = 1 + 2 = 3
 * 3. (1, 2), (4, 3) → min(1, 2) + min(4, 3) = 1 + 3 = 4
 * Максимальная сумма - 4.
 *
 * Пример 2
 * Вход: nums = [6,2,6,5,1,2]
 * Выход: 9
 * Объяснение:
 * Оптимальное разбиение: (1, 2), (2, 6), (5, 6).
 * Сумма минимумов: 1 + 2 + 5 = 9.
 *
 * Оптимальное решение - сортировка и выбор пар
 * Литкод считает, что это не самое быстрое решение
 *
 * todo пока не понятно
 */
class Solution {
    public int arrayPairSum(int[] nums) {
        // Сортируем массив
        Arrays.sort(nums);

        int sum = 0;
        // Берем каждый второй элемент (начиная с первого)
        for (int i = 0; i < nums.length; i += 2) {
            sum += nums[i];
        }

        return sum;
    }
}
/*
Оптимальное решение (сортировка и выбор пар)
Ключевая идея: чтобы максимизировать сумму минимумов пар, нужно чтобы
в каждой паре числа были как можно ближе друг к другу.
Это достигается сортировкой массива и созданием пар из последовательных элементов.
Сортируем массив
Суммируем каждый второй элемент (начиная с первого)
Временная сложность: O(n log n) из-за сортировки
Пространственная сложность: O(1) или O(n) в зависимости от реализации сортировки
 */
