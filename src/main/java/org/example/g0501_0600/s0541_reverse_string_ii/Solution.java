package org.example.g0501_0600.s0541_reverse_string_ii;

// #Easy #String #Two_Pointers #Char

/**
 * 541. Reverse String II
 *
 * Дана строка s и целое число k. Необходимо обращать первые
 * k символов для каждых 2k символов, начиная с начала строки.
 *
 * Правила:
 * Если в оставшейся части строки меньше k символов, но больше
 * или равно 1 символу, обратить все оставшиеся символы
 * Если осталось меньше 2k символов, но больше или равно k символов,
 * обратить первые k символов и оставить остальные как есть
 * Обращение происходит для каждых 2k символов от начала строки
 *
 * todo запутанные условия
 *
 * Важные уточнения:
 * Строка состоит только из строчных английских букв
 * 1 <= k <= 10^4
 * 1 <= s.length <= 10^4
 * (примеры внизу)
 *
 * Решение с указателями - самое быстрое решение - 0 ms
 *
 * Объяснение подхода:
 * Итерация с шагом 2k: Проходим по строке, обрабатывая блоки по 2k символов
 * Определение границ обращения: Для каждого блока обращаем первые
 * k символов (или меньше, если осталось меньше k)
 * Двухточечное обращение: Используем два указателя
 * для эффективного обращения подмассива
 *
 */
class Solution {
    public String reverseStr(String s, int k) {
        // Преобразуем строку в массив символов для удобства работы
        char[] charArray = s.toCharArray();
        int length = charArray.length;

        // Проходим по строке с шагом 2k
        for (int startIndex = 0; startIndex < length; startIndex += 2 * k) {
            // Определяем начало и конец отрезка для обращения
            int left = startIndex;
            // Правый указатель: либо startIndex + k - 1, либо конец строки
            int right = Math.min(startIndex + k - 1, length - 1);

            // Обращаем отрезок от left до right
            reverseSubarray(charArray, left, right);
        }

        // Возвращаем результат как строку
        return new String(charArray);
    }

    // Вспомогательный метод для обращения подмассива
    private void reverseSubarray(char[] array, int left, int right) {
        // Используем два указателя для обращения отрезка
        while (left < right) {
            // Меняем местами символы
            char temp = array[left];
            array[left] = array[right];
            array[right] = temp;

            // Сдвигаем указатели
            left++;
            right--;
        }
    }
}
/*
Пример 1:
Вход: s = "abcdefg", k = 2
Ответ: "bacdfeg"
Объяснение:
Первые 4 символа (2k = 4): "abcd" → обращаем первые k=2: "bacd"
Следующие 4 символа: "efg" (осталось 3 символа, что меньше 4)
→ обращаем первые k=2: "feg" становится "gef", но так как осталось
только 3 символа, обращаем все 3: "feg" → "gef"
Итог: "bacd" + "gef" = "bacdgef" (в примере "bacdfeg" - видимо опечатка в объяснении)

Пример 2:
Вход: s = "abcd", k = 2
Ответ: "bacd"
Объяснение: Первые 4 символа: обращаем первые 2 → "bacd"

Пример 3:
Вход: s = "abcdefghij", k = 3
Ответ: "cbadefihgj"
Объяснение:
Первые 6 символов (2k=6): "abcdef" → обращаем первые 3: "cba" + "def"
Следующие 6 символов: "ghij" (осталось 4) → обращаем первые 3: "ihg" + "j"
Итог: "cba" + "def" + "ihg" + "j" = "cbadefihgj"

 */