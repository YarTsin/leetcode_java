package org.example.g2301_2400.s2389_longest_subsequence_with_limited_sum;

// #Easy #Array #Sorting #Greedy #Binary_Search #Prefix_Sum #Pointers

import java.util.Arrays;

/**
 * 2389. Longest Subsequence With Limited Sum
 *
 * Дан массив целых чисел nums и массив целых чисел queries.
 * Необходимо для каждого запроса queries[i] найти длину самой длинной
 * подпоследовательности nums, сумма элементов которой
 * не превышает queries[i].
 *
 * Важные моменты:
 * Подпоследовательность - это последовательность, которая может быть
 * получена из другой последовательности удалением некоторых элементов
 * без изменения порядка оставшихся элементов
 * Можно выбирать любые элементы в исходном порядке
 * Нужно максимизировать длину подпоследовательности при ограничении на сумму
 *
 * todo запутанное условие
 *
 * Пример 1
 * Вход: nums = [4,5,2,1], queries = [3,10,21]
 * Выход: [2,3,4]
 * Объяснение:
 * - Для queries[0] = 3: самая длинная подпоследовательность с суммой ≤ 3 - [2,1] (длина 2)
 * - Для queries[1] = 10: самая длинная подпоследовательность с суммой ≤ 10 - [4,5,1] (длина 3)
 * - Для queries[2] = 21: можно взять все элементы [4,5,2,1] (длина 4)
 *
 * Пример 2
 * Вход: nums = [2,3,4,5], queries = [1]
 * Выход: [0]
 * Объяснение: Нет подпоследовательности с суммой ≤ 1
 *
 * Эффективное решение: (сортировка + префиксные суммы + бинарный поиск)
 *
 * это 2 по скорости решение - 5 ms
 *
 */
class Solution {
    public int[] answerQueries(int[] nums, int[] queries) {
        int n = nums.length;
        int m = queries.length;

        // Сортируем массив nums
        Arrays.sort(nums);

        // Создаем массив префиксных сумм
        int[] prefixSums = new int[n];
        prefixSums[0] = nums[0];
        for (int i = 1; i < n; i++) {
            prefixSums[i] = prefixSums[i - 1] + nums[i];
        }

        // Для каждого запроса находим максимальную длину
        int[] result = new int[m];
        for (int i = 0; i < m; i++) {
            int query = queries[i];

            // Используем бинарный поиск для нахождения максимального индекса,
            // где префиксная сумма <= query
            int left = 0;
            int right = n - 1;
            int maxLength = 0;

            while (left <= right) {
                int mid = left + (right - left) / 2;

                if (prefixSums[mid] <= query) {
                    maxLength = mid + 1; // длина = индекс + 1
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            result[i] = maxLength;
        }

        return result;
    }
}
/*
Объяснение:
Сложность: O(n log n + m log n) времени, O(n) дополнительной памяти
Подход:
Сортируем массив nums - чтобы брать наименьшие элементы для максимизации длины
Создаем массив префиксных сумм отсортированного массива
Для каждого запроса используем бинарный поиск по префиксным суммам,
чтобы найти максимальную длину подпоследовательности с суммой ≤ query
 */
