Подходы к решению
1. Рекурсия с мемоизацией
Прямолинейный рекурсивный подход, но с запоминанием результатов для избежания повторных вычислений.

2. Динамическое программирование (оптимальное)
Используем массив для хранения промежуточных результатов.

3. Оптимизированное ДП (константная память)
Используем только несколько переменных вместо массива.

==============

Объяснение для новичка
Базовые случаи:

Для 1 ступеньки - только 1 способ
Для 2 ступенек - 2 способа (1+1 или 2)

Массив dp:
dp[i] хранит количество способов подняться на i-ю ступеньку
Каждый следующий элемент вычисляется как сумма двух предыдущих

Формула:
dp[i] = dp[i-1] + dp[i-2]
Потому что на i-ю ступеньку можно попасть либо с (i-1) (сделав 1 шаг), либо с (i-2) (сделав 2 шага)

Временная сложность
O(n) - один проход по всем ступенькам от 3 до n.

Пространственная сложность
O(n) - для хранения массива dp.

=========
public class Solution {
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }

        int prev1 = 1; // Для i-1
        int prev2 = 2; // Для i-2
        int current = 0;

        for (int i = 3; i <= n; i++) {
            current = prev1 + prev2;
            prev1 = prev2;
            prev2 = current;
        }

        return current;
    }
}