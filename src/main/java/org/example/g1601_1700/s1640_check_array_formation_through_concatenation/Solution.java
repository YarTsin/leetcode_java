package org.example.g1601_1700.s1640_check_array_formation_through_concatenation;

// #Easy #Array #Hashmap

import java.util.HashMap;
import java.util.Map;

/**
 * 1640. Check Array Formation Through Concatenation
 *
 * Вам дан массив различных целых чисел arr и массив кусочков
 * (pieces) pieces, где элементы pieces также являются массивами
 * целых чисел. Ваша задача — определить, можно ли получить исходный
 * массив arr, соединив массивы из pieces в любом порядке, но без
 * изменения порядка элементов внутри каждого кусочка.
 *
 * Ключевые моменты:
 * Все целые числа в arr уникальны.
 * Все целые числа в pieces также уникальны.
 * Вы можете соединять кусочки в любом порядке.
 * Вы не можете переставлять элементы внутри кусочка.
 * (примеры внизу)
 *
 * Решение - с Hashmap - 2-е по скорости - 1 ms
 *
 * Временная сложность: O(n), где n — длина массива arr.
 * Мы проходим по arr только один раз, а проверка каждого
 * кусочка также вносит линейный вклад.
 *
 * Пространственная сложность: O(m), где m — количество
 * кусочков (для хранения HashMap).
 *
 */
class Solution {
    public boolean canFormArray(int[] arr, int[][] pieces) {
        // Создаем HashMap для быстрого поиска кусочков по первому элементу
        // Ключ: первый элемент кусочка
        // Значение: сам кусочек (массив)
        Map<Integer, int[]> pieceMap = new HashMap<>();

        // Заполняем карту: для каждого кусочка ключом становится его первый элемент
        for (int[] piece : pieces) {
            pieceMap.put(piece[0], piece);
        }

        // Индекс для прохода по целевому массиву arr
        int index = 0;

        // Пока не пройдем весь массив arr
        while (index < arr.length) {
            // Пытаемся найти кусочек, который начинается с текущего элемента arr[index]
            if (pieceMap.containsKey(arr[index])) {
                // Получаем кусочек, который должен идти следующим
                int[] currentPiece = pieceMap.get(arr[index]);

                // Проверяем, совпадает ли весь текущий кусочек с последовательностью в arr
                for (int num : currentPiece) {
                    // Если вышли за границы arr или элемент не совпадает
                    if (index >= arr.length || num != arr[index]) {
                        return false;
                    }
                    index++; // Переходим к следующему элементу
                }
            } else {
                // Если не нашли кусочек, начинающийся с текущего элемента - массив собрать невозможно
                return false;
            }
        }

        // Если успешно прошли весь массив - возвращаем true
        return true;
    }
}
/*
Пример 1
Вход: arr = [15,88], pieces = [[88],[15]]
Выход: true
Объяснение: Соединяем [15] + [88] = [15,88]

Пример 2
Вход: arr = [49,18,16], pieces = [[16,18,49]]
Выход: false
Объяснение: Даже если числа те же, порядок внутри
кусочка не соответствует порядку в arr.
Мы не можем изменить порядок внутри кусочка [16,18,49], чтобы получить [49,18,16].

Пример 3
Вход: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
Выход: true
Объяснение: Соединяем [91] + [4,64] + [78] = [91,4,64,78]
 */