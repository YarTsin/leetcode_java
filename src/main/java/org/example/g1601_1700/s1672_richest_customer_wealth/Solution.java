package org.example.g1601_1700.s1672_richest_customer_wealth;

// #Easy #Array #Matrix

/**
 * 1672. Richest Customer Wealth
 *
 * Вам дан двумерный целочисленный массив accounts, где:
 * accounts[i] представляет счет i-го клиента
 * accounts[i][j] представляет сумму денег на j-м счете i-го клиента
 * Необходимо найти максимальное богатство, которое имеет клиент.
 * Богатство клиента определяется как сумма денег на всех его счетах.
 *
 * Ключевые моменты:
 * Каждый клиент может иметь несколько счетов (банковских аккаунтов)
 * Нужно найти клиента с максимальной общей суммой на всех счетах
 * Возвращается именно сумма, а не индекс клиента
 * (примеры внизу)
 *
 * Решение - итерационное - самое быстрое 0 ms
 *
 * Временная сложность: O(n × m) где n - количество клиентов,
 * m - среднее количество счетов на клиента
 * Пространственная сложность: O(1) - используем только константную
 * дополнительную память
 *
 */
class Solution {
    public int maximumWealth(int[][] accounts) {
        int maxWealth = 0;

        // Проходим по каждому клиенту
        for (int i = 0; i < accounts.length; i++) {
            int currentWealth = 0;

            // Суммируем все счета текущего клиента
            for (int j = 0; j < accounts[i].length; j++) {
                currentWealth += accounts[i][j];
            }

            // Обновляем максимальное богатство, если текущее больше
            if (currentWealth > maxWealth) {
                maxWealth = currentWealth;
            }
        }

        return maxWealth;
    }
}
/*
Пример 1
Вход: accounts = [[1,2,3],[3,2,1]]
Выход: 6
Объяснение:
1-й клиент: 1 + 2 + 3 = 6
2-й клиент: 3 + 2 + 1 = 6
Оба имеют богатство 6

Пример 2
Вход: accounts = [[1,5],[7,3],[3,5]]
Выход: 10
Объяснение:
1-й клиент: 1 + 5 = 6
2-й клиент: 7 + 3 = 10
3-й клиент: 3 + 5 = 8
Максимальное богатство: 10
 */