Подходы к решению
1. Наивный подход (проверка всех возможных k)
Последовательно проверять word × k для увеличивающихся k, пока находим вхождение.

2. Оптимальный подход (построение возможных строк)
Генерировать возможные строки word × k и проверять их вхождение.

3. Эффективный поиск (использование индексов)
Поиск максимального k без избыточных проверок.

================

Временная сложность
O(n*m), где:
n - длина sequence
m - длина word × k (для максимального k)

Пространственная сложность
O(m*k) - для хранения повторяющейся строки word × k

=================

Дополнительные вопросы
1. Как изменить решение, если word может быть пустой строкой?
Добавить проверку if (word.isEmpty()) return 0;

2. Как найти все возможные k, а не только максимальное?
Сохранять все k, при которых word × k содержится в sequence

3. Как оптимизировать для очень длинных sequence?
Использовать алгоритм Кнута-Морриса-Пратта (KMP) для поиска подстрок

4. Как обработать случай, когда word длиннее sequence?
Добавить проверку if (word.length() > sequence.length()) return 0;

===================

Вариации задачи
Проверка точного повторения (слово повторяется k раз подряд без разрывов)
Поиск максимального непересекающегося повторения
Поиск наиболее часто повторяющейся подстроки фиксированной длины