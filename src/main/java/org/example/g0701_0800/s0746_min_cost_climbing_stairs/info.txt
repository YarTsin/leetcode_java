Подходы к решению
1. Рекурсия с мемоизацией
Рекурсивный перебор всех вариантов с запоминанием результатов.

2. Динамическое программирование (оптимальное)
Использование массива для хранения промежуточных результатов.

3. Оптимизированное ДП (константная память)
Использование только нескольких переменных вместо массива.

Оптимальное решение (динамическое программирование)

=================

Пояснения

Инициализация массива dp:
dp[i] будет хранить минимальную стоимость достижения i-й ступеньки
Размер массива n + 1 (чтобы включить вершину после последней ступеньки)

Базовые случаи:
dp[0] = cost[0] (стоимость начала с 0-й ступеньки)
dp[1] = cost[1] (стоимость начала с 1-й ступеньки)

Заполнение массива:
Для каждой ступеньки от 2 до n:
- Вычисляем стоимость текущей позиции (для вершины - 0)
- Минимальная стоимость = минимум из двух предыдущих + текущая стоимость

Результат:
dp[n] содержит минимальную стоимость достижения вершины

========

Временная сложность
O(n) - один проход по всем ступенькам.

Пространственная сложность
O(n) - для хранения массива dp.

==========

Дополнительные вопросы для собеседования
1. Как изменить решение, если можно шагать на 1, 2 или 3 ступеньки?
Добавить третью переменную и брать минимум из трех предыдущих значений

2. Как найти не только стоимость, но и путь?
Сохранять информацию о выборе (откуда пришли) в дополнительном массиве

3. Что если некоторые ступеньки "заблокированы"?
Добавить проверку доступности ступеньки перед вычислением

4. Как решить задачу с ограниченным бюджетом?
Добавить проверку на превышение бюджета во время вычислений

============

Вариации задачи
Climbing Stairs (Leetcode 70) - без стоимости, только количество способов
Maximum Score From Performing Multiplication Operations (Leetcode 1770) - аналогичный подход ДП
House Robber (Leetcode 198) - похожая логика выбора оптимального пути


