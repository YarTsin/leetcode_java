package org.example.g0701_0800.s0762_prime_number_of_set_bits_in_binary_representation;

// #Easy #Math #Bit_Manipulation #Кернигана

/**
 * 762. Prime Number of Set Bits in Binary Representation
 * Условие: Даны два целых числа L и R. Нужно найти количество
 * чисел в диапазоне [L, R] (включительно), у которых количество единиц
 * в их двоичном представлении (set bits) является простым числом.
 * (примеры внизу)
 *
 * Ключевые моменты:
 * Простое число — это натуральное число больше 1, которое
 * имеет ровно два делителя: 1 и само себя.
 * Set Bits — это количество битов со значением 1 в двоичной записи числа.
 * Диапазон L и R гарантированно будет 1 <= L <= R <= 10^6.
 *
 * todo проверить ограничения
 *
 * Решение - Побитовый подсчет с предвычислением простых чисел
 * не самое быстрое - 4 ms
 *
 * Основная идея:
 * Предвычисление простых чисел: Максимально возможное количество
 * единиц в числе для данного ограничения (R <= 10^6) — это 20,
 * так как 2^20 = 1,048,576, что больше 10^6.
 * Следовательно, нам нужны простые числа только в диапазоне от 0 до 20.
 * Мы можем заранее создать массив (или Set), где isPrime[i] будет true,
 * если i — простое число.
 *
 * Перебор диапазона: Для каждого числа i в интервале [L, R]:
 * Подсчитать количество единиц в его двоичном представлении
 * (Integer.bitCount(i)).
 * Проверить, является ли это количество простым (посмотрев
 * в наш заранее созданный массив isPrime).
 * Если да, увеличить счетчик.
 *
 * Почему это эффективно:
 * Сложность по времени: O(N), где N = R - L + 1.
 * Для каждого числа мы делаем проверку за O(1).
 * Сложность по памяти: O(1). Мы используем массив фиксированного
 * размера (21 элемент) для хранения флагов простых чисел.
 * Метод Integer.bitCount() в Java — это встроенная высокооптимизированная
 * нативная функция, которая использует efficient bit-level operations.
 */
class Solution {
    public int countPrimeSetBits(int L, int R) {
        // Массив для отметки, является ли число простым (индекс = число).
        // Размер 21, так как max количество бит для чисел <= 10^6 равно 20.
        boolean[] isPrime = new boolean[21];

        // Инициализируем массив. Сначала все false.
        // Помечаем простые числа вручную для диапазона 0..20.
        // Простые числа в этом диапазоне: 2, 3, 5, 7, 11, 13, 17, 19.
        isPrime[2] = true;
        isPrime[3] = true;
        isPrime[5] = true;
        isPrime[7] = true;
        isPrime[11] = true;
        isPrime[13] = true;
        isPrime[17] = true;
        isPrime[19] = true;
        // Числа 0, 1 и все четные >2 - не простые, они остаются false.

        // Инициализируем счетчик
        int count = 0;

        // Проходим по каждому числу в заданном диапазоне [L, R]
        for (int num = L; num <= R; num++) {
            // Считаем количество единичных битов в числе 'num'
            int bitCount = Integer.bitCount(num);
            // Проверяем, является ли это количество простым числом
            if (isPrime[bitCount]) {
                count++;
            }
        }

        return count;
    }
}
/*
Пример 1:
Ввод: L = 6, R = 10
Вывод: 4
Объяснение:
6 -> 110 (2 единицы). 2 — простое число. ✅
7 -> 111 (3 единицы). 3 — простое число. ✅
8 -> 1000 (1 единица). 1 — не простое число. ❌
9 -> 1001 (2 единицы). 2 — простое число. ✅
10-> 1010 (2 единицы). 2 — простое число. ✅
Итого, числа 6, 7, 9, 10 удовлетворяют условию. Ответ: 4.

Пример 2:

Ввод: L = 10, R = 15

Вывод: 5
Объяснение:
10 -> 1010 (2 единицы) -> простое. ✅
11 -> 1011 (3 единицы) -> простое. ✅
12 -> 1100 (2 единицы) -> простое. ✅
13 -> 1101 (3 единицы) -> простое. ✅
14 -> 1110 (3 единицы) -> простое. ✅
15 -> 1111 (4 единицы) -> 4 не простое. ❌
Итого, 5 чисел.
 */
