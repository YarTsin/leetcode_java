Решение: подсчет частотности букв
Основная идея:
Нормализация licensePlate:
Привести все символы к нижнему регистру.
Оставить только буквы.
Подсчитать, сколько раз встречается каждая буква.
Будем хранить это в массиве licenseFrequency размером
26 (для букв от 'a' до 'z').


Поиск по массиву words:
Для каждого слова в массиве:
Подсчитать частотность его букв (также в массиве размером 26).
Проверить, что для каждой буквы i частота в слове >= частоте в licenseFrequency.
Если это условие выполняется для всех букв, слово является завершающим.
Сравнивать длину завершающих слов и выбрать самое короткое
(а если длины равны — первое из них).

Почему это эффективно:
Сложность по времени: O(N * L), где N — количество слов в массиве,
а L — средняя длина слова. Это оптимально, так как нам в любом случае
нужно проверить каждый символ в каждом слове.
Сложность по памяти: O(1). Мы используем массивы фиксированного
размера (26 элементов) для подсчета частот.