package org.example.g0701_0800.s0703_kth_largest_element_in_a_stream;

// #Easy #Tree #Binary_Tree #Design #Heap_Priority_Queue #Priority_Queue
// #Binary_Search_Tree #Data_Stream

import java.util.PriorityQueue;

/**
 * 703. Kth Largest Element in a Stream
 *
 * Необходимо разработать класс, который находит k-й наибольший элемент
 * в потоке целых чисел. Класс должен поддерживать добавление новых
 * элементов и возможность быстро получать k-й наибольший элемент
 * после каждого добавления.
 *
 * Концепция
 * Идея заключается в том, что мы постоянно получаем поток чисел
 * и после каждого нового числа нам нужно быстро определить k-й наибольший
 * элемент среди всех полученных до этого чисел.
 * (примеры внизу)
 *
 * Важно
 * Ваш KthLargest объект будет создан и вызван следующим образом:
 * KthLargest obj = new KthLargest(k, nums);
 * int param_1 = obj.add(val);
 *
 * Решение с Min-Heap - не быстрое 20 ms
 * Преимущества:
 * Временная сложность добавления: O(log k)
 * Пространственная сложность: O(k)
 * Очень эффективно для больших потоков данных
 */
class Solution { //Если сдавать на проверку класс должен быть KthLargest
    private final int k;
    private final PriorityQueue<Integer> minHeap;

    // Конструктор инициализирует структуру данных с k и начальными элементами
    public Solution(int k, int[] nums) {
        this.k = k;
        this.minHeap = new PriorityQueue<>(k);

        // Добавляем начальные элементы в min-heap
        for (int num : nums) {
            add(num);
        }
    }

    // Добавляет новый элемент и возвращает k-й наибольший элемент
    public int add(int val) {
        // Если в куче меньше k элементов, просто добавляем новый элемент
        if (minHeap.size() < k) {
            minHeap.offer(val);
        }
        // Если новый элемент больше наименьшего элемента в куче
        else if (val > minHeap.peek()) {
            // Удаляем наименьший элемент (он не может быть k-м наибольшим)
            minHeap.poll();
            // Добавляем новый элемент
            minHeap.offer(val);
        }
        // Если куча содержит k элементов, возвращаем наименьший из них
        // (который будет k-м наибольшим элементом)
        return minHeap.peek();
    }
}


/*
Пример 1

KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // возвращает 4
kthLargest.add(5);   // возвращает 5
kthLargest.add(10);  // возвращает 5
kthLargest.add(9);   // возвращает 8
kthLargest.add(4);   // возвращает 8

Объяснение подхода:
Используем min-heap (приоритетную очередь), которая всегда хранит
k наибольших элементов
Верхушка кучи (minHeap.peek()) всегда содержит k-й наибольший элемент
При добавлении нового элемента:
Если куча еще не заполнена (меньше k элементов), просто добавляем элемент
Если новый элемент больше текущего k-го наибольшего, заменяем наименьший элемент в куче
В противном случае игнорируем элемент (он меньше всех k наибольших)
 */
