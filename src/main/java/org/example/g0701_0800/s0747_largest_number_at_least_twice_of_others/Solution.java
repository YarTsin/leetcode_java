package org.example.g0701_0800.s0747_largest_number_at_least_twice_of_others;

/**
 * #Easy #Array
 * Вам дан массив целых чисел nums, где есть ровно один наибольший элемент.
 * Необходимо определить, является ли этот наибольший элемент по крайней мере
 * в два раза больше каждого из остальных чисел в массиве. Если да, вернуть индекс
 * этого элемента, иначе вернуть -1.
 *
 * Пример 1  * Вход: [3, 6, 1, 0]   * Выход: 1
 * Объяснение:
 * 6 - наибольший элемент, и:
 * 6 ≥ 2*3 = 6 (верно)
 * 6 ≥ 2*1 = 2 (верно)
 * 6 ≥ 2*0 = 0 (верно)
 *
 * Пример 2  * Вход: [1, 2, 3, 4]  * Выход: -1
 * Объяснение:
 * 4 - наибольший элемент, но:
 * 4 ≥ 2*3 = 6 (ложь)
 *
 * (0 ms)
 */
class Solution {
    public int dominantIndex(int[] nums) {
        if (nums.length == 1) return 0;

        int maxIndex = 0;
        int maxValue = nums[0];
        int secondMax = Integer.MIN_VALUE; //второй по величине

        // Находим максимальный элемент и второй по величине
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > maxValue) {
                secondMax = maxValue;
                maxValue = nums[i];
                maxIndex = i;
            } else if (nums[i] > secondMax) {
                secondMax = nums[i];
            }
        }

        // Проверяем условие maxValue ≥ 2*secondMax
        return maxValue >= 2 * secondMax ? maxIndex : -1;
    }
}
/*
Объяснение решения:
Обработка частного случая:
Если массив содержит только один элемент, сразу возвращаем 0

Поиск двух наибольших элементов:
Проходим по массиву, сохраняя максимальный элемент и второй по величине
Запоминаем индекс максимального элемента

Проверка условия:
Проверяем, что максимальный элемент хотя бы в два раза больше второго по величине
Возвращаем индекс максимального элемента или -1

Временная сложность: O(n) - один проход по массиву
Пространственная сложность: O(1) - константное количество переменных
 */