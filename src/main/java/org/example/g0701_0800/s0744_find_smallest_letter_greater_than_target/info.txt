1. Двоичный поиск (оптимальный)
Сложность: O(log n) по времени, O(1) по памяти
Основные шаги:
Используем стандартный двоичный поиск, но с модификацией
Ищем не точное совпадение, а первый элемент, больший целевого
Если все элементы меньше или равны целевому, возвращаем первый элемент
Ключевые моменты:
letters[mid] <= target - ищем в правой половине, так как нам нужен элемент БОЛЬШЕ целевого
left % letters.length - обеспечивает циклическое поведение (если left == length, возвращаем letters[0])

2. Линейный поиск
Сложность: O(n) по времени, O(1) по памяти
Основные шаги:
Последовательно проверяем каждый элемент массива
Возвращаем первый найденный элемент, больший целевого
Если такого нет - возвращаем первый элемент

Недостатки:
Менее эффективен для больших массивов
Не использует преимущества отсортированности массива