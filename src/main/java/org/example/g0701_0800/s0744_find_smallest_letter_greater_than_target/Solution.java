package org.example.g0701_0800.s0744_find_smallest_letter_greater_than_target;

/**
 * #Easy #Array #BinarySearch #Char
 * 744. Find Smallest Letter Greater Than Target
 *
 * Дан массив символов letters, отсортированный в неубывающем
 * порядке (некоторые буквы могут повторяться), и целевой символ
 * target. Необходимо найти наименьший символ в массиве, который
 * больше целевого символа.
 *
 * Особенности:
 * Массив отсортирован в порядке неубывания
 * Буквы могут повторяться
 * Если такого символа не существует (все символы меньше или равны целевому),
 * нужно вернуть первый символ массива
 * Это циклический поиск - после 'z' следует 'a
 *
 * Пример 1
 * Вход: letters = ["c","f","j"], target = "a"
 * Выход: "c"
 * Объяснение: Первая буква, большая чем "a", это "c"
 *
 * Пример 2
 * Вход: letters = ["c","f","j"], target = "c"
 * Выход: "f"
 * Объяснение: Первая буква, большая чем "c", это "f"
 *
 * Пример 3
 * Вход: letters = ["x","x","y","y"], target = "z"
 * Выход: "x"
 * Объяснение: Так как "z" больше всех букв в массиве,
 * возвращаем первую букву (циклический поиск)
 *
 * Оптимальное решение - модифицированный двоичный поиск
 *
 * это самое быстрое решение - 0 ms
 */
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int left = 0;
        int right = letters.length - 1;

        // Используем двоичный поиск для нахождения позиции
        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (letters[mid] <= target) {
                // Если средний элемент меньше или равен целевому,
                // ищем в правой половине (нам нужен элемент БОЛЬШЕ целевого)
                left = mid + 1;
            } else {
                // Если средний элемент больше целевого,
                // возможно это наш кандидат, но нужно проверить левую половину
                right = mid - 1;
            }
        }

        // Если left вышел за границы массива, значит все элементы <= target
        // Возвращаем первый элемент (циклический случай)
        // Оператор % обеспечивает циклическое поведение
        return letters[left % letters.length];
    }
}
