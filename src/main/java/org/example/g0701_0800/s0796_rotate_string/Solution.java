package org.example.g0701_0800.s0796_rotate_string;

// #Easy #String #String_Matching #Math #KMP

/**
 * 796. Rotate String
 *
 * Условие: Даны две строки s и goal. Нужно проверить,
 * можно ли получить строку goal из строки s, выполнив
 * некоторое количество циклических сдвигов (вращений).
 *
 * Что такое циклический сдвиг?
 * Циклический сдвиг строки s на k позиций означает:
 * Взять первые k символов строки s и переместить их в конец
 * Или эквивалентно: взять последние len(s) - k символов
 * и переместить их в начало
 *
 * Формально: После сдвига строка s становится равной
 * s[k] + s[k+1] + ... + s[n-1] + s[0] + s[1] + ... + s[k-1]
 * (примеры внизу)
 *
 * Решение Проверка является ли goal подстрокой s + s
 * Самое быстрое решение - 0 ms
 */
class Solution {
    public boolean rotateString(String s, String goal) {
        // Если длины строк не равны, goal не может быть циклическим сдвигом s
        if (s.length() != goal.length()) {
            return false;
        }

        // Создаем удвоенную строку s
        String doubledString = s + s;

        // Проверяем, содержится ли goal в doubledString
        return doubledString.contains(goal);
    }
}
/*
Пример 1:
Ввод: s = "abcde", goal = "cdeab"
Вывод: true
Объяснение:
Сдвиг на 2 позиции: "abcde" → "cdeab"
"abcde" → убираем "ab" из начала и добавляем в конец

Пример 2:
Ввод: s = "abcde", goal = "abced"
Вывод: false
Объяснение: Не существует такого сдвига,
который превратит "abcde" в "abced"
 */