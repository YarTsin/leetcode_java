package org.example.g0701_0800.s0717_1_bit_and_2_bit_characters;

// #Easy #Array

/**
 * 717. 1-bit and 2-bit Characters
 *
 * У нас есть два специальных типа символов:
 * 1-битный символ: представлен битом 0
 * 2-битный символ: представлен двумя битами 10 или 11
 *
 * Дан массив bits, который заканчивается на 0.
 * Необходимо определить, является ли последний символ 1-битным символом.
 * Другими словами, нужно проверить, может ли массив битов быть
 * корректно декодирован таким образом, что последний символ
 * будет 1-битным.
 *
 * todo запутанное условие
 *
 * Особенности реализации
 * Массив bits будет содержать только 0 и 1
 * Массив всегда заканчивается на 0
 * Длина массива будет в диапазоне [1, 1000]
 * (примеры внизу)
 *
 * Решение с линейным проходом - самое быстрое - 0 ms
 *
 * Временная сложность: O(n)
 * Пространственная сложность: O(1)
 *
 */
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int index = 0;
        int n = bits.length;

        // Проходим по массиву до предпоследнего элемента
        while (index < n - 1) {
            // Если текущий бит равен 1, это должен быть 2-битный символ
            // Пропускаем следующий бит (потому что 2-битный символ использует 2 бита)
            if (bits[index] == 1) {
                index += 2; // Пропускаем 2 бита
            } else {
                index += 1; // Пропускаем 1 бит (1-битный символ)
            }
        }

        // Если мы остановились точно на последнем элементе (n-1),
        // значит последний символ - 1-битный
        return index == n - 1;
    }
}
/*
Пример 1
Input: bits = [1, 0, 0]
Output: true
Объяснение:
Единственный способ декодировать:
1-битный символ: 1, 0 -> невалидно (10 или 11 должны быть 2-битными)
2-битный символ: 10 и затем 1-битный: 0
Таким образом, последний символ - 1-битный.

Пример 2
Input: bits = [1, 1, 1, 0]
Output: false
Объяснение:
Единственный способ декодировать:
2-битный символ: 11, затем 2-битный символ: 10
Таким образом, последний символ - 2-битный, а не 1-битный.
 */
