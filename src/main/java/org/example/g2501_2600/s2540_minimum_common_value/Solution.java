package org.example.g2501_2600.s2540_minimum_common_value;

// #Easy #Array #Hash_Table #Binary_Search #Two_Pointers


/**
 * 2540. Minimum Common Value
 *
 * Даны два целочисленных массива nums1 и nums2, которые отсортированы
 * в порядке неубывания. Необходимо найти минимальное общее значение,
 * которое присутствует в обоих массивах. Если общего значения нет, вернуть -1.
 *
 * Пример 1
 * Вход: nums1 = [1,2,3], nums2 = [2,4]
 * Выход: 2
 * Объяснение: Наименьшее общее значение - 2
 *
 * Пример 2
 * Вход: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
 * Выход: 2
 * Объяснение: Есть два общих значения: 2 и 3, минимальное - 2
 *
 * Пример 3
 * Вход: nums1 = [1,2,3], nums2 = [4,5,6]
 * Выход: -1
 * Объяснение: Нет общих значений
 *
 * Эффективный подход - два указателя
 *
 * Это третье по скорости решение - 2 ms
 */
class Solution {
    public int getCommon(int[] nums1, int[] nums2) {
        int pointer1 = 0;
        int pointer2 = 0;
        int length1 = nums1.length;
        int length2 = nums2.length;

        // Используем два указателя для обхода обоих массивов
        while (pointer1 < length1 && pointer2 < length2) {
            if (nums1[pointer1] == nums2[pointer2]) {
                return nums1[pointer1]; // Нашли минимальное общее значение
            } else if (nums1[pointer1] < nums2[pointer2]) {
                pointer1++; // Увеличиваем указатель первого массива
            } else {
                pointer2++; // Увеличиваем указатель второго массива
            }
        }

        return -1; // Общих значений не найдено
    }
}

/*
Объяснение:
Сложность: O(n + m) времени, O(1) дополнительной памяти
Подход: Используем два указателя для одновременного обхода
обоих отсортированных массивов
Принцип работы: Сравниваем текущие элементы массивов и двигаем указатель
того массива, где элемент меньше
 */