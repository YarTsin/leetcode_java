Подходы к решению
1. Жадный алгоритм (оптимальный)
Построение подпоследовательности по ходу итерации, выбирая элементы с разными соседними группами.

2. Динамическое программирование
Более сложный подход с запоминанием возможных подпоследовательностей.

==============

Объяснение для новичка
Инициализация:
Создаем список result для хранения результата
Первый элемент всегда включаем в результат
Запоминаем его группу в lastGroup

Проход по массиву:
Для каждого следующего элемента проверяем, отличается ли его группа от последней добавленной
Если отличается - добавляем в результат и обновляем lastGroup

Результат:
Возвращаем построенную подпоследовательность

===================

Почему это работает?
Жадный алгоритм оптимален, потому что:
Каждый подходящий элемент добавляется сразу
Пропуск элемента не может увеличить длину конечной подпоследовательности
Сохраняется порядок исходного массива

==================

Временная сложность
O(n) - один проход по массиву, где n - количество элементов.

Пространственная сложность
O(n) - в худшем случае храним все элементы (если группы все разные).

===================

Дополнительные вопросы
1. Как изменить решение, если нужно вернуть индексы вместо слов?
Сохранять в списке не words[i], а просто i

2. Как найти все возможные подпоследовательности максимальной длины?
Потребуется более сложный алгоритм с запоминанием путей

3. Что если группы могут быть null?
Добавить проверки на null в условии сравнения

4. Как оптимизировать память, если нужен только размер подпоследовательности?
Можно просто считать элементы, не сохраняя их

======================
Вариации задачи
Longest Alternating Subsequence - чередование по другому правилу
Longest Increasing Subsequence - классическая задача
With Additional Constraints - например, ограничение на длину слов



