package org.example.g1101_1200.s1122_relative_sort_array;

// #Easy #Array #Hash_Table #Sorting #Counting_Sort

/**
 * 1122. Relative Sort Array
 * Даны два массива: arr1 и arr2. Элементы в arr2
 * уникальны и все элементы arr2 присутствуют в arr1.
 *
 * Задача: Отсортировать arr1 таким образом, чтобы:
 * Относительный порядок элементов в arr1 совпадал с порядком в arr2
 * Элементы, не присутствующие в arr2, должны быть размещены в конце
 * в возрастающем порядке
 * (примеры внизу)
 *
 * Решение - с Counting Sort - самое быстрое - 0 ms
 */
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        // Находим максимальное значение в arr1 для создания массива подсчета
        int max = 0;
        for (int num : arr1) {
            if (num > max) {
                max = num;
            }
        }

        // Создаем массив для подсчета частот
        int[] count = new int[max + 1];
        for (int num : arr1) {
            count[num]++;
        }

        // Заполняем результат элементами из arr2 в нужном порядке
        int[] result = new int[arr1.length];
        int index = 0;

        // Сначала добавляем элементы в порядке arr2
        for (int num : arr2) {
            while (count[num] > 0) {
                result[index++] = num;
                count[num]--;
            }
        }

        // Затем добавляем оставшиеся элементы в возрастающем порядке
        for (int i = 0; i <= max; i++) {
            while (count[i] > 0) {
                result[index++] = i;
                count[i]--;
            }
        }

        return result;
    }
}
/*

Пример 1
Ввод: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Вывод: [2,2,2,1,4,3,3,9,6,7,19]
Объяснение:
- Элементы [2,1,4,3,9,6] идут в порядке arr2
- Остальные элементы [7,19] идут в конце в возрастающем порядке

Пример 2
Ввод: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
Вывод: [22,28,8,6,17,44]
Объяснение:
- Элементы [22,28,8,6] идут в порядке arr2
- Остальные [17,44] идут в конце и отсортированы
 */