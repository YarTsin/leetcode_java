package org.example.g1401_1500.s1403_minimum_subsequence_in_non_increasing_order;

// #Easy #Array #Sorting #Greedy

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 1403. Minimum Subsequence in Non-Increasing Order
 *
 * Дан массив целых чисел nums. Необходимо найти такую
 * подпоследовательность (не обязательно смежные элементы, но сохраняющая
 * исходный порядок), что:
 * - Сумма элементов этой подпоследовательности строго больше суммы
 * всех остальных элементов массива.
 * - Подпоследовательность должна иметь минимально возможный размер
 * (содержать как можно меньше элементов).
 * - Если существует несколько решений с одинаковым минимальным размером,
 * нужно выбрать то, у которого максимальная сумма элементов
 * (чтобы гарантировать условие №1).
 * - Подпоследовательность должна быть возвращена в невозрастающем
 * порядке (от большего к меньшему).
 *
 * Проще говоря: Нужно выбрать наименьшее количество самых больших
 * чисел из массива так, чтобы их сумма была больше суммы всех остальных чисел.
 *
 * Важные замечания:
 * Подпоследовательность — это последовательность, которая может быть
 * получена из исходного массива удалением некоторых элементов без
 * изменения порядка оставшихся элементов.
 *
 * Решение гарантированно существует (всегда можно найти хотя бы одну
 * такую подпоследовательность).
 * (примеры внизу)
 *
 * Решение - используем Жадный алгоритм - не быстрое решение - 1 ms
 *
 * Основная идея:
 * Отсортировать массив в порядке убывания (от большего к меньшему)
 * Посчитать общую сумму всех элементов массива
 * Последовательно добавлять самые большие элементы в результат, пока сумма выбранных элементов не станет строго больше половины общей суммы
 * Вернуть выбранные элементы (они уже будут в нужном порядке)
 *
 */
class Solution {
    public List<Integer> minSubsequence(int[] nums) {
        // Шаг 1: Сортируем массив в порядке убывания
        int[] sorted = nums.clone();
        Arrays.sort(sorted);
        // Разворачиваем отсортированный массив для получения убывающего порядка
        for (int i = 0; i < sorted.length / 2; i++) {
            int temp = sorted[i];
            sorted[i] = sorted[sorted.length - 1 - i];
            sorted[sorted.length - 1 - i] = temp;
        }

        // Шаг 2: Вычисляем общую сумму всех элементов
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }

        // Шаг 3: Последовательно добавляем самые большие элементы
        List<Integer> result = new ArrayList<>();
        int currentSum = 0;

        for (int num : sorted) {
            result.add(num);
            currentSum += num;

            // Проверяем условие: currentSum > totalSum - currentSum
            // Это эквивалентно currentSum > totalSum / 2
            if (currentSum > totalSum - currentSum) {
                break;
            }
        }

        return result;
    }
}
/*
Пример 1
Ввод: nums = [4,3,10,9,8]
Объяснение:
Общая сумма массива: 4+3+10+9+8 = 34
Отсортируем массив: [10,9,8,4,3]
Берем наибольшие числа пока их сумма не станет больше половины общей суммы:
10 > 34-10=24? 10 > 24? Нет
10+9=19 > 34-19=15? 19 > 15? Да!
Берем [10,9] → сортируем в порядке неубывания: [10,9]
Вывод: [10,9]

Пример 2:
Ввод: nums = [4,4,7,6,7]
Объяснение:
Общая сумма: 4+4+7+6+7 = 28
Отсортируем: [7,7,6,4,4]
Проверяем:
7 > 28-7=21? Нет
7+7=14 > 28-14=14? 14 > 14? Нет (строго больше!)
7+7+6=20 > 28-20=8? 20 > 8? Да
Берем [7,7,6] → сортируем: [7,7,6]
Вывод: [7,7,6]
 */