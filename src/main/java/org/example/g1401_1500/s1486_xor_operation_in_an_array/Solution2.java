package org.example.g1401_1500.s1486_xor_operation_in_an_array;

/**
 *  Математически оптимизированное решение (проверить)
 *
 *  Существует более сложное математическое решение, основанное
 *  на свойствах XOR и паттернах, которые образует последовательность
 *  чисел вида s, s+2, s+4, .... Оно имеет константную сложность O(1)
 *
 *  Объяснение подхода: Идея заключается в том, чтобы выразить результат
 *  через XOR более простых последовательностей. Заметим, что наш массив
 *  — это последовательность четных чисел, сдвинутая на start.
 *
 *  Можно воспользоваться формулой для нахождения XOR всех чисел
 *  от a до b (xorRange(a, b)), но наша последовательность имеет шаг 2.
 *
 *  Формула для xorRange(a, b) выглядит так:
 *  xorRange(a, b) = xorRange(1, a-1) ^ xorRange(1, b)
 *  А xorRange(1, n) можно вычислить по известному паттерну
 *  в зависимости от остатка n % 4.
 *
 *  Однако наша последовательность — это f(i) = (start/2 + i) * 2, если
 *  start четное, или f(i) = (start/2 + i) * 2 + 1, если start нечетное.
 *  Это позволяет свести задачу к вычислению XOR последовательности
 *  обычных целых чисел с последующим сдвигом и корректировкой.
 *
 *  Временная сложность: O(1). Все вычисления выполняются за константное время.
 *  Пространственная сложность: O(1).
 */
class Solution2 {
    public int xorOperation(int n, int start) {
        // Вычисляем первый "виртуальный" элемент последовательности после деления на 2
        int firstNumber = start >> 1;

        // Вычисляем последний "виртуальный" элемент
        int lastNumber = firstNumber + n - 1;

        // Вычисляем XOR для последовательности целых чисел от firstNumber до lastNumber
        int xorOfIntegers = computeXOROfRange(firstNumber, lastNumber);

        // Поскольку наша исходная последовательность была умножена на 2 (и, возможно, имела +1),
        // нам нужно сдвинуть результат обратно и учечеть младший бит.
        // Сдвигаем результат вычислений влево (умножаем на 2)...
        int result = xorOfIntegers << 1;

        // ... и добавляем младший бит.
        // Если start нечетное И количество нечетных чисел в последовательности (т.е. n) нечетное,
        // то итоговый результат тоже будет иметь установленный младший бит.
        if ((start & 1) == 1 && (n & 1) == 1) {
            result |= 1; // Устанавливаем младший бит в 1
        }

        return result;
    }

    // Вспомогательная функция для вычисления XOR всех чисел от a до b включительно.
    private int computeXOROfRange(int a, int b) {
        if (a == 0) {
            return computeXORFrom1ToN(b);
        } else {
            return computeXORFrom1ToN(a - 1) ^ computeXORFrom1ToN(b);
        }
    }

    // Вспомогательная функция для вычисления XOR всех чисел от 1 до n.
    // Работает на основе наблюдаемого паттерна:
    // n % 4 == 0 -> n
    // n % 4 == 1 -> 1
    // n % 4 == 2 -> n+1
    // n % 4 == 3 -> 0
    private int computeXORFrom1ToN(int n) {
        switch (n % 4) {
            case 0:
                return n;
            case 1:
                return 1;
            case 2:
                return n + 1;
            case 3:
                return 0;
        }
        return 0; // Сюда выполнение не дойдет, но компилятор требует return
    }
}
