package org.example.g1401_1500.s1413_minimum_value_to_get_positive_step_by_step_sum;

// #Easy #Array #Prefix_Sum

/**
 * 1413. Minimum Value to Get Positive Step by Step Sum
 *
 * Дан массив целых чисел nums. Вы начинаете с начального
 * положительного значения startValue. На каждой
 * итерации вы вычисляете пошаговую сумму, начиная с startValue,
 * и добавляете элементы массива nums по порядку.
 *
 * Нужно найти минимальное положительное значение startValue,
 * такое чтобы пошаговая сумма никогда не опускалась ниже 1
 * на любом этапе вычислений.
 * (примеры внизу)
 *
 * Ограничения:
 * 1 <= nums.length <= 100
 * -100 <= nums[i] <= 100
 *
 * Решение в 1 проход с использованием префиксных сумм
 * Самое быстрое - 0ms
 *
 * Временная сложность: O(n) - один проход по массиву
 * Пространственная сложность: O(1) - константная память
 */
class Solution {
    public int minStartValue(int[] nums) {
        int minPrefixSum = 0;    // Минимальная префиксная сумма
        int currentSum = 0;      // Текущая накапливаемая сумма

        // Проходим по всем элементам массива
        for (int num : nums) {
            currentSum += num;           // Добавляем текущий элемент к сумме
            minPrefixSum = Math.min(minPrefixSum, currentSum); // Обновляем минимум
        }

        // startValue должно компенсировать минимальную отрицательную сумму
        // Если minPrefixSum отрицательный, нужно добавить |minPrefixSum| + 1
        // Если minPrefixSum неотрицательный, достаточно startValue = 1
        return Math.max(1, 1 - minPrefixSum);
    }
}
/*
Пример 1
Input: nums = [-3,2,-3,4,2]
Output: 5
Объяснение:
Если startValue = 5:
- Пошаговая сумма: 5, 5+(-3)=2, 2+2=4, 4+(-3)=1, 1+4=5, 5+2=7
Все суммы ≥ 1, поэтому 5 - минимальное подходящее значение

Пример 2
Input: nums = [1,2]
Output: 1
Объяснение:
Минимальное startValue = 1. Пошаговая сумма: 1, 1+1=2, 2+2=4

Пример 3
Input: nums = [1,-2,-3]
Output: 5
Объяснение:
Если startValue = 5:
- Пошаговая сумма: 5, 5+1=6, 6+(-2)=4, 4+(-3)=1
Все суммы ≥ 1
 */