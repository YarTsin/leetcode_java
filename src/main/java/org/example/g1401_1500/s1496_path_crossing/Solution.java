package org.example.g1401_1500.s1496_path_crossing;

// #Easy #String #Hash_Table


import java.util.HashSet;
import java.util.Set;

/**
 * 1496. Path Crossing
 *
 * Дана строка path, где каждый символ является одним из следующих:
 * 'N', 'S', 'E', 'W', обозначающих движение на одну единицу на север, юг,
 * восток и запад соответственно.
 * Предполагается, что путь начинается в точке с координатами (0, 0).
 * Задача: Определить, пересекает ли путь сам себя в любой точке. Другими словами,
 * возвращает true, если путь проходит через одну и ту же точку более одного раза,
 * и false в противном случае.
 *
 * Решение с использованием HashSet - не быстрое - 5 ms
 *
 *
 * Подход: Ключевая идея — отслеживать каждую посещенную точку.
 * Если в какой-то момент мы приходим в точку, которая уже была посещена,
 * путь пересекается.
 *
 * Сложность:
 * Временная сложность: O(n), где n — длина строки path.
 * Мы выполняем цикл n раз, и на каждой итерации операции
 * с HashSet (добавление и проверка) выполняются в среднем за O(1).
 * Пространственная сложность: O(n). В худшем случае, если путь не пересекается,
 * мы сохраним все n+1 точек (начальная + n шагов) в HashSet.
 *
 */
class Solution {
    public boolean isPathCrossing(String path) {
        // Текущие координаты
        int x = 0;
        int y = 0;

        // Множество (Set) для хранения всех посещенных точек в виде строки "x,y"
        Set<String> visitedPoints = new HashSet<>();

        // Добавляем начальную точку (0, 0) в множество посещенных
        String initialPoint = x + "," + y;
        visitedPoints.add(initialPoint);

        // Проходим по каждому символу в строке пути
        for (char direction : path.toCharArray()) {
            // Обновляем координаты в зависимости от текущего направления
            switch (direction) {
                case 'N': y++; break; // Движение на Север (увеличение y)
                case 'S': y--; break; // Движение на Юг (уменьшение y)
                case 'E': x++; break; // Движение на Восток (увеличение x)
                case 'W': x--; break; // Движение на Запад (уменьшение x)
            }

            // Формируем строковое представление новой текущей точки
            String currentPoint = x + "," + y;

            // Проверяем, была ли эта точка посещена ранее
            if (visitedPoints.contains(currentPoint)) {
                // Если точка уже есть в множестве, путь пересекся
                return true;
            }

            // Если точка новая, добавляем ее в множество для отслеживания
            visitedPoints.add(currentPoint);
        }

        // Если весь путь пройден и не было найдено пересечений, возвращаем false
        return false;
    }
}
/*
Пример 1
Ввод: path = "NES"
Визуализация:
Начало: (0, 0)
'N': (0, 0) -> (0, 1)
'E': (0, 1) -> (1, 1)
'S': (1, 1) -> (1, 0)
Путь: (0,0) → (0,1) → (1,1) → (1,0)
Анализ: Все точки уникальны.
Вывод: false

Пример 2
Ввод: path = "NESWW"
Визуализация:
Начало: (0, 0)
'N': (0, 0) -> (0, 1)
'E': (0, 1) -> (1, 1)
'S': (1, 1) -> (1, 0)
'W': (1, 0) -> (0, 0) ← Возврат в начальную точку (0,0)!
'W': (0, 0) -> (-1, 0)
Анализ: Точка (0, 0) посещается дважды (в начале и в конце 4-го шага).
Вывод: true
*/
