package org.example.g1401_1500.s1480_running_sum_of_1d_array;

// #Easy #Array #Prefix_Sum

/**
 * 1480. Running Sum of 1d Array
 *
 * Дан массив целых чисел nums. Необходимо вычислить и вернуть бегущую сумму
 * (running sum) массива.
 *
 * Бегущая сумма массива определяется как runningSum[i] = sum(nums[0]…nums[i]).
 * Другими словами, каждый элемент результирующего массива представляет собой
 * сумму всех элементов исходного массива от начала до текущей
 * позиции включительно.
 * (примеры внизу)
 *
 * Решение - Итеративное накопление суммы
 * Самое быстрое решение - 0 ms
 *
 * Сложность: O(n) по времени, O(1) по памяти
 * (если модифицируем исходный массив) и
 * ли O(n) (если создаем новый массив)
 *
 * Подход:
 * Проходим по массиву, накапливая сумму элементов
 * и сохраняя промежуточные результаты.
 *
 */
class Solution {
    public int[] runningSum(int[] nums) {
        int n = nums.length;
        int[] runningSum = new int[n];

        // Первый элемент остается без изменений
        runningSum[0] = nums[0];

        // Для каждого последующего элемента: текущая сумма =
        // предыдущая сумма + текущий элемент
        for (int i = 1; i < n; i++) {
            runningSum[i] = runningSum[i - 1] + nums[i];
        }

        return runningSum;
    }
}
/*
Пример 1
Входные данные: nums = [1,2,3,4]
Выходные данные: [1,3,6,10]
Объяснение:
Бегущая сумма вычисляется следующим образом:
[1, 1+2, 1+2+3, 1+2+3+4] = [1, 3, 6, 10]

Пример 2
Входные данные: nums = [1,1,1,1,1]
Выходные данные: [1,2,3,4,5]
Объяснение:
Бегущая сумма: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] = [1, 2, 3, 4, 5]

Пример 3
Входные данные: nums = [3,1,2,10,1]
Выходные данные: [3,4,6,16,17]
Объяснение:
Бегущая сумма: [3, 3+1, 3+1+2, 3+1+2+10, 3+1+2+10+1] = [3, 4, 6, 16, 17]
 */