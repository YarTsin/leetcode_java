package org.example.g1001_1100.s1022_sum_of_root_to_leaf_binary_numbers;

// #Easy #Depth_First_Search #Tree #Binary_Tree
// #Recursion

import org.example.a_leetcode_classes.TreeNode;

/**
 * 1022. Sum of Root To Leaf Binary Numbers
 * Дан корень бинарного дерева, где каждый узел имеет
 * значение 0 или 1. Каждый путь от корня до листа представляет
 * собой двоичное число, где значение узла представляет собой
 * бит (0 или 1), а путь определяет порядок битов (старший бит идет первым).
 *
 * Например, путь 1 -> 0 -> 1 представляет двоичное число 101,
 * которое в десятичной системе равно 5.
 *
 * Необходимо вычислить сумму всех чисел, представленных путями
 * от корня до каждого листа в дереве. Ответ гарантированно помещается
 * в 32-битное целое число.
 * (примеры внизу)
 *
 * Решение - рекурсивный DFS с накоплением значения
 * Самое быстрое решение - 0 ms
 *
 * Сложность:
 * Временная сложность: O(n), где n - количество узлов в дереве.
 * Мы посещаем каждый узел ровно один раз.
 * Пространственная сложность: O(h), где h - высота дерева.
 * Это пространство используется для рекурсивного стека вызовов.
 * В худшем случае (вырожденное дерево) h = n, в сбалансированном
 * дереве h = log(n).
 *
 */
class Solution {
    // Инициализируем переменную для хранения общей суммы
    private int totalSum = 0;

    public int sumRootToLeaf(TreeNode root) {
        // Запускаем DFS обход с корня и начальным значением 0
        traverse(root, 0);
        return totalSum;
    }

    private void traverse(TreeNode node, int currentNumber) {
        if (node == null) {
            return;
        }

        // Обновляем текущее число: сдвигаем влево и добавляем значение текущего узла
        // Эквивалентно: currentNumber = currentNumber * 2 + node.val
        currentNumber = (currentNumber << 1) | node.val;

        // Проверяем, является ли узел листом (нет потомков)
        if (node.left == null && node.right == null) {
            // Если это лист, добавляем текущее число к общей сумме
            totalSum += currentNumber;
            return;
        }

        // Рекурсивно обходим левое и правое поддеревья
        traverse(node.left, currentNumber);
        traverse(node.right, currentNumber);
    }
}
/*
Пример 1

Ввод: [1,0,1,0,1,0,1]
        1
      /   \
     0     1
    / \   / \
   0   1 0   1

Вывод: 22
Объяснение:
Пути от корня до листьев и соответствующие числа:
1) 1 -> 0 -> 0: 100 (4 в десятичной)
2) 1 -> 0 -> 1: 101 (5 в десятичной)
3) 1 -> 1 -> 0: 110 (6 в десятичной)
4) 1 -> 1 -> 1: 111 (7 в десятичной)
Сумма = 4 + 5 + 6 + 7 = 22

 */