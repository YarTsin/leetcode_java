package org.example.g1001_1100.s1030_matrix_cells_in_distance_order;

// #Easy #Array #Math #Sorting #Matrix #Geometry

/**
 * 1030. Matrix Cells in Distance Order
 * Даны четыре целых числа:
 * rows - количество строк матрицы
 * cols - количество столбцов матрицы
 * rCenter - индекс строки центральной ячейки
 * cCenter - индекс столбца центральной ячейки
 *
 * Необходимо вернуть координаты всех ячеек матрицы в порядке
 * возрастания расстояния от центральной ячейки (rCenter, cCenter).
 * Если у двух ячеек одинаковое расстояние, они могут быть возвращены
 * в любом порядке.
 *
 * Расстояние между двумя ячейками (r1, c1) и (r2, c2) вычисляется
 * по манхэттенской метрике:
 * |r1 - r2| + |c1 - c2|
 * (примеры внизу)
 *
 * Решение - с использованием BFS и очереди
 * Не быстрое - 8 ms
 *
 * Сложность:
 * Временная сложность: O(rows * cols) - мы посещаем
 * каждую ячейку ровно один раз
 * Пространственная сложность: O(rows * cols) -
 * для хранения посещенных ячеек и очереди
 */
import java.util.ArrayDeque;
import java.util.Queue;

class Solution {
    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {
        // Результирующий массив
        int[][] result = new int[rows * cols][2];
        int index = 0;

        // Матрица для отслеживания посещенных ячеек
        boolean[][] visited = new boolean[rows][cols];

        // Очередь для BFS
        Queue<int[]> queue = new ArrayDeque<>();

        // Начинаем с центральной ячейки
        queue.offer(new int[]{rCenter, cCenter});
        visited[rCenter][cCenter] = true;

        // Направления движения: вверх, вправо, вниз, влево
        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int r = current[0];
            int c = current[1];

            // Добавляем текущую ячейку в результат
            result[index++] = new int[]{r, c};

            // Проверяем всех соседей
            for (int[] dir : directions) {
                int newR = r + dir[0];
                int newC = c + dir[1];

                // Проверяем, что новые координаты в пределах матрицы и не посещены
                if (newR >= 0 && newR < rows && newC >= 0 && newC < cols && !visited[newR][newC]) {
                    queue.offer(new int[]{newR, newC});
                    visited[newR][newC] = true;
                }
            }
        }

        return result;
    }
}
/*
Пример 1
Ввод: rows = 1, cols = 2, rCenter = 0, cCenter = 0
Вывод: [[0,0],[0,1]]
Объяснение:
Расстояния от (0,0):
- до (0,0): |0-0| + |0-0| = 0
- до (0,1): |0-0| + |1-0| = 1
Ячейки уже упорядочены по расстоянию.

Пример 2
Ввод: rows = 2, cols = 2, rCenter = 0, cCenter = 1
Вывод: [[0,1],[0,0],[1,1],[1,0]]
Объяснение:
Расстояния от (0,1):
- до (0,1): |0-0| + |1-1| = 0
- до (0,0): |0-0| + |0-1| = 1
- до (1,1): |1-0| + |1-1| = 1
- до (1,0): |1-0| + |0-1| = 2
Порядок: [0,1], затем ячейки с расстоянием 1 ([0,0] и [1,1]), затем [1,0].

Пример 3
Ввод: rows = 2, cols = 3, rCenter = 1, cCenter = 2
Вывод: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
Объяснение:
Расстояния от (1,2):
- до (1,2): |1-1| + |2-2| = 0
- до (0,2): |0-1| + |2-2| = 1
- до (1,1): |1-1| + |1-2| = 1
- до (0,1): |0-1| + |1-2| = 2
- до (1,0): |1-1| + |0-2| = 2
- до (0,0): |0-1| + |0-2| = 3
 */
