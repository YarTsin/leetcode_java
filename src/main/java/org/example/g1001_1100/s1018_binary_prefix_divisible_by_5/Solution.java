package org.example.g1001_1100.s1018_binary_prefix_divisible_by_5;

// #Easy #Array #Math #Bits

import java.util.ArrayList;
import java.util.List;

/**
 * 1018. Binary Prefix Divisible By 5
 *
 * Дан массив nums бинарных цифр (0 и 1). Для каждого индекса
 * i (от 0 до nums.length - 1) необходимо вычислить двоичное число,
 * образованное префиксом массива от 0 до i (включительно), и проверить,
 * делится ли это число на 5 без остатка.
 *
 * Требуется вернуть список (или массив) булевых значений answer,
 * где answer[i] будет true, если число, образованное префиксом
 * nums[0..i], делится на 5, и false в противном случае.
 * (примеры внизу)
 *
 * Важное примечание:
 * Числа, представленные префиксами, могут быть очень большими
 * (массив длиной до 100 000 элементов). Прямое преобразование
 * двоичной строки в десятичное число с помощью Integer.parseInt()
 * или BigInteger приведет к переполнению или будет неэффективным.
 * Необходимо использовать математические свойства деления и модулярную
 * арифметику.
 *
 * Решение - с помощью модулярной арифметики
 * 2 по скорости - 3 ms
 *
 * Сложность:
 * Временная сложность: O(n), где n - длина массива nums.
 * Мы проходим по массиву ровно один раз.
 * Пространственная сложность: O(1), если не считать выходной
 * массив (O(n)). Мы используем только несколько переменных
 * для хранения промежуточного состояния.
 */
class Solution {
    public List<Boolean> prefixesDivBy5(int[] nums) {
        // Создаем список для хранения результатов
        List<Boolean> answer = new ArrayList<>();
        // Инициализируем переменную для хранения текущего остатка от деления на 5
        int currentRemainder = 0;

        // Проходим по каждому биту во входном массиве
        for (int bit : nums) {
            // Вычисляем новый остаток на основе предыдущего.
            // (currentRemainder * 2) % 5 эквивалентно (currentRemainder * 2),
            // так как currentRemainder всегда меньше 5.
            // Затем прибавляем текущий бит и берем модуль от результата по основанию 5.
            currentRemainder = (currentRemainder * 2 + bit) % 5;

            // Если остаток равен 0, число делится на 5 нацело
            boolean isDivisible = (currentRemainder == 0);
            answer.add(isDivisible);
        }

        return answer;
    }
}
/*
Пример 1
Ввод: nums = [0,1,1]
Вывод: [true, false, false]
Объяснение:
i=0: Число = 0 (в двоичной) -> 0 (в десятичной). 0 % 5 == 0 -> true.
i=1: Число = 01 (в двоичной) -> 1 (в десятичной). 1 % 5 == 1 -> false.
i=2: Число = 011 (в двоичной) -> 3 (в десятичной). 3 % 5 == 3 -> false.

Пример 2
Ввод: nums = [1,1,1]
Вывод: [false, false, false]
Объяснение:
i=0: Число = 1 -> 1 % 5 = 1 -> false.
i=1: Число = 11 -> 3 % 5 = 3 -> false.
i=2: Число = 111 -> 7 % 5 = 2 -> false.
*/