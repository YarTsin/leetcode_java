package org.example.g1001_1100.s1005_maximize_sum_of_array_after_k_negations;

import java.util.Arrays;

/**
 * #Easy #Array #Sort #Greedy
 * Условие:
 * Дан массив целых чисел nums и целое число k.
 * За одну операцию можно выбрать любой элемент массива и изменить
 * его знак (т.е., nums[i] становится -nums[i]).
 *
 * Задача
 * Необходимо выполнить ровно k таких операций и вернуть
 * максимально возможную сумму массива после этих операций.
 *
 * Важные детали:
 * Можно многократно изменять знак одного и того же элемента
 * Требуется выполнить ровно k операций (не меньше и не больше)
 * Цель - максимизировать сумму всех элементов массива
 *
 * todo непонятное условие
 *
 * Пример 1:  * Вход: nums = [4,2,3], k = 1  * Выход: 5
 * Объяснение: Изменим знак у 2 → [4,-2,3], сумма = 4 + (-2) + 3 = 5
 *
 * Пример 2:  * Вход: nums = [3,-1,0,2], k = 3 * Выход: 6
 * Объяснение: [3,-1,0,2] → [3,1,0,2] → [3,1,0,-2] → [3,1,0,2], сумма = 3+1+0+2 = 6
 *
 * По скорости решение третье - 3 ms
 *
 */
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        // Сортируем массив для удобства работы с отрицательными числами
        Arrays.sort(nums);

        int n = nums.length;
        int sum = 0;
        int minAbsoluteValue = Integer.MAX_VALUE;

        // Проходим по массиву и применяем операции к отрицательным числам
        for (int i = 0; i < n; i++) {
            // Если есть доступные операции и текущее число отрицательное
            if (k > 0 && nums[i] < 0) {
                nums[i] = -nums[i]; // Меняем знак
                k--; // Уменьшаем количество оставшихся операций
            }

            // Обновляем сумму
            sum += nums[i];

            // Отслеживаем минимальное абсолютное значение в массиве
            minAbsoluteValue = Math.min(minAbsoluteValue, nums[i]);
        }

        // Если остались неиспользованные операции (k > 0)
        if (k > 0) {
            // Если количество оставшихся операций нечетное
            if (k % 2 == 1) {
                // Вычитаем дважды минимальное значение (так как мы уже добавили его в сумму)
                sum -= 2 * minAbsoluteValue;
            }
        }

        return sum;
    }
}

/*
Объяснение оптимального решения
Подход:
Сортируем массив - это позволяет сначала обработать все отрицательные числа
Инвертируем отрицательные числа - меняем знак у самых маленьких (самых отрицательных) чисел,
так как это дает наибольший прирост к сумме
Если остались операции - если после инвертирования всех отрицательных
чисел остались операции, используем их на минимальном положительном числе
Учитываем четность оставшихся операций - если осталось нечетное количество
операций, один раз меняем знак минимального элемента
Сложность: O(n log n) из-за сортировки, где n - длина массива
 */
