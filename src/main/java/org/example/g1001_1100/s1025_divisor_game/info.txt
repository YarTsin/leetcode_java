Подходы к решению
1. Математический анализ (оптимальное)
Анализ выигрышных и проигрышных позиций.

2. Динамическое программирование
Запоминание результатов для всех чисел до n.

3. Рекурсия с мемоизацией
Рекурсивная проверка всех возможных ходов.

==========================

Пояснения

Базовые случаи:
n = 1: Алиса не может ходить → false
n = 2: Алиса выбирает 1 → Боб получает 1 → true
n = 3: Алиса вынуждена выбрать 1 → Боб получает 2 → Боб выигрывает → false

Закономерность:
Для четных n Алиса всегда может передать Бобу нечетное число
Для нечетных n любой делитель будет нечетным, и n-x будет четным
Таким образом, игрок с четным числом может всегда передавать нечетное

Вывод:
Алиса выигрывает ⇔ n четное

============================

Временная сложность
O(1) - просто проверка четности числа.

Пространственная сложность
O(1) - не используем дополнительной памяти.

===========================

Дополнительные вопросы для собеседования
1. Как изменить решение, если первый ход делает Боб?
Вернуть n % 2 != 0

2. Что если игроки могут выбирать любой делитель (не только меньший n)?
Логика остается той же, так как x должно быть < n по условию

3.Как найти выигрышный ход для Алисы?
Для четного n выбрать x=1, чтобы передать нечетное число

4. Как изменится решение, если проигрывает тот, кто делает последний ход?
Это другой тип игры (normal play vs misère play), потребует другого анализа

============================
Математическое доказательство
По индукции:

База: n=1 (проигрыш), n=2 (выигрыш)

Шаг:
Если n нечетное: все делители нечетные → n-x четное → противник получает выигрышную позицию
Если n четное: можно выбрать x=1 → передать нечетное n-1

Таким образом, оптимальная стратегия - всегда оставлять противнику нечетное число.

Простое решение с проверкой четности является оптимальным и наиболее эффективным для данной задачи.


